<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crypto Price Chart</title>
    <link rel="icon" href="favicon.ico" type="image/x-icon">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        body {
            background-color: #f8f9fa;
        }

        /* Chart-specific styles */
        .chart-container {
            width: 100%;
            height: 500px;
            position: relative;
        }

        .line {
            fill: none;
            stroke: #ff9900;
            stroke-width: 2;
        }

        .area {
            fill: rgba(255, 153, 0, 0.1);
        }

        .axis {
            font-size: 12px;
        }

        .axis path, .axis line {
            fill: none;
            stroke: #ccc;
            shape-rendering: crispEdges;
        }

        .grid line {
            fill: none;
            stroke: #e0e0e0;
            shape-rendering: crispEdges;
        }

        .grid path {
            stroke-width: 0;
        }

        .loading {
            text-align: center;
            color: #6c757d;
            margin: 20px 0;
            font-style: italic;
        }

        /* Price guide styles */
        .price-guide {
            position: absolute;
            pointer-events: none;
            left: 70px;
            right: 50px;
            opacity: 0;
            transition: opacity 0.1s;
        }

        .price-guide-line {
            position: absolute;
            height: 0;
            width: 100%;
            border-top: 1px dashed #555;
        }

        .price-guide-label {
            position: absolute;
            right: -45px;
            transform: translateY(-50%);
            background-color: #555;
            color: white;
            font-size: 12px;
            padding: 3px 8px;
            border-radius: 3px;
        }

        .current-price-label {
            position: absolute;
            background-color: #0d6efd;
            color: white;
            font-size: 12px;
            padding: 3px 8px;
            border-radius: 3px;
            pointer-events: none;
            font-weight: bold;
            text-align: center;
            right: 5px;
        }

        /* Price percentage label */
        .price-guide-percent {
            position: absolute;
            right: -45px;
            transform: translateY(-50%);
            background-color: #555;
            color: white;
            font-size: 11px;
            padding: 2px 6px;
            border-radius: 3px;
            top: 20px;
        }

        /* Price range selection */
        .price-range-zone {
            position: absolute;
            background-color: rgba(13, 110, 253, 0.15);
            left: 70px;
            right: 50px;
            pointer-events: none;
            border-top: 1px dashed #0d6efd;
            border-bottom: 1px dashed #0d6efd;
        }

        .price-range-label {
            position: absolute;
            right: -45px;
            transform: translateY(-50%);
            background-color: #0d6efd;
            color: white;
            font-size: 12px;
            padding: 3px 8px;
            border-radius: 3px;
        }

        /* Responsive containers */
        .chart-container {
            width: 100% !important;
            height: auto !important;
            min-height: 300px;
        }

        /* Make sure SVG scales correctly */
        svg {
            display: block;
            max-width: 100%;
            height: auto;
        }

        /* Ensure price guides adapt to screen size */
        .price-guide-line {
            left: 0;
            width: 100%;
        }

        /* Adjust controls for smaller screens */
        @media (max-width: 768px) {
            .form-check {
                margin-right: 8px;
            }

            .fw-bold {
                font-size: 14px;
            }

            #chart-title {
                font-size: 1.5rem;
            }

            .axis text {
                font-size: 10px;
            }
        }

        /* Very small screens */
        @media (max-width: 480px) {
            .form-check {
                margin-bottom: 8px;
            }

            .price-guide-label, .price-range-label, .current-price-label {
                font-size: 10px;
                padding: 2px 4px;
            }

            .axis text {
                font-size: 9px;
            }

            .axis path, .axis line {
                stroke-width: 0.5px;
            }
        }
    </style>
</head>
<body>
<div class="container py-4">
    <h1 id="chart-title" class="text-center mb-4">BTC/USDT 1h Price Chart</h1>
    <div id="loading" class="loading">Loading data...</div>

    <div class="card shadow-sm mb-4">
        <div class="card-body">
            <!-- First row: Coins and Interval side by side -->
            <div class="row g-3 mb-3">
                <!-- Symbol Selection -->
                <div class="col-md-6">
                    <h5 class="fw-bold mb-3">Coins:</h5>
                    <div class="d-flex flex-wrap gap-3">
                        <div class="form-check">
                            <input class="form-check-input" type="radio" id="symbol-btcusdt" name="symbol"
                                   value="BTCUSDT" checked>
                            <label class="form-check-label" for="symbol-btcusdt">BTC</label>
                        </div>
                        <div class="form-check">
                            <input class="form-check-input" type="radio" id="symbol-ethusdt" name="symbol"
                                   value="ETHUSDT">
                            <label class="form-check-label" for="symbol-ethusdt">ETH</label>
                        </div>
                        <div class="form-check">
                            <input class="form-check-input" type="radio" id="symbol-xrpusdt" name="symbol"
                                   value="XRPUSDT">
                            <label class="form-check-label" for="symbol-xrpusdt">XRP</label>
                        </div>
                        <div class="form-check">
                            <input class="form-check-input" type="radio" id="symbol-solusdt" name="symbol"
                                   value="SOLUSDT">
                            <label class="form-check-label" for="symbol-solusdt">SOL</label>
                        </div>
                        <div class="form-check">
                            <input class="form-check-input" type="radio" id="symbol-bnbusdt" name="symbol"
                                   value="BNBUSDT">
                            <label class="form-check-label" for="symbol-bnbusdt">BNB</label>
                        </div>
                        <div class="form-check">
                            <input class="form-check-input" type="radio" id="symbol-tonusdt" name="symbol"
                                   value="TONUSDT">
                            <label class="form-check-label" for="symbol-tonusdt">TON</label>
                        </div>
                    </div>
                </div>

                <!-- Interval Selection -->
                <div class="col-md-6">
                    <h5 class="fw-bold mb-3">Interval:</h5>
                    <div class="d-flex flex-wrap gap-3">
                        <div class="form-check">
                            <input class="form-check-input" type="radio" id="interval-1h" name="interval" value="1h"
                                   checked>
                            <label class="form-check-label" for="interval-1h">1h</label>
                        </div>
                        <div class="form-check">
                            <input class="form-check-input" type="radio" id="interval-2h" name="interval" value="2h">
                            <label class="form-check-label" for="interval-2h">2h</label>
                        </div>
                        <div class="form-check">
                            <input class="form-check-input" type="radio" id="interval-4h" name="interval" value="4h">
                            <label class="form-check-label" for="interval-4h">4h</label>
                        </div>
                        <div class="form-check">
                            <input class="form-check-input" type="radio" id="interval-1d" name="interval" value="1d">
                            <label class="form-check-label" for="interval-1d">1d</label>
                        </div>
                        <div class="form-check">
                            <input class="form-check-input" type="radio" id="interval-3d" name="interval" value="3d">
                            <label class="form-check-label" for="interval-3d">3d</label>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Second row: Limit and Threshold sliders side by side -->
            <div class="row g-3">
                <!-- Data Limit Slider -->
                <div class="col-md-6">
                    <div class="mb-3">
                        <label for="limit-slider" class="form-label fw-bold">Limit:</label>
                        <div class="d-flex align-items-center gap-2">
                            <input type="range" class="form-range flex-grow-1" id="limit-slider" min="10" max="500"
                                   step="10" value="100">
                            <span id="limit-value" class="badge bg-secondary">100</span>
                        </div>
                    </div>
                </div>

                <!-- Threshold Slider -->
                <div class="col-md-6">
                    <div class="mb-3">
                        <label for="precision-slider" class="form-label fw-bold">Smooth:</label>
                        <div class="d-flex align-items-center gap-2">
                            <input type="range" class="form-range flex-grow-1" id="precision-slider" min="0" max="1000"
                                   step="1" value="0">
                            <span id="precision-value" class="badge bg-secondary">$0</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="card shadow-sm mb-4">
        <div class="card-body p-0">
            <div id="chart-container" class="chart-container">
                <!-- Price guide element (absolute positioned) -->
                <div id="price-guide" class="price-guide">
                    <div class="price-guide-line"></div>
                    <div class="price-guide-label"></div>
                    <div class="price-guide-percent"></div>
                </div>
                <!-- Current price label (matches hover guide style) -->
                <div id="current-price-label" class="current-price-label"></div>
                <!-- Price range selection elements will be added here in JS -->
            </div>
        </div>
    </div>

    <button id="refresh" class="btn btn-warning d-block mx-auto">Refresh Data</button>
</div>

<!-- Bootstrap Bundle with Popper -->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
<script src="utils.js"></script>
<!-- Chart JavaScript code will go here -->
<!--need you to make some fixes-->
<!--* text for extrema-label positioned incorrectly in the extrema-label rectangle (extra shifted top for red rectangles and bottom for green)-->
<!--* we don't need "Price (USDT)" label at all so we can free this space to make chart more wider on a small screen-->
<!--* date-range-label is to close to the top-->
<!--* make all labels except axis labels inside a chart - for example current price label, on mouse hover lines label with hovered price, etc-->
<!--* extrema-labels looks nice for big prices like btc and eth but need to show decimals for small price coins like xrp, so fix the formatting check but do not hardcode -->
<!--* chart settings are too bloated and should be refactored to be more compact (take less space vertically)) -->
<!--* put smooth and limit sliders to the bottom of the chart make label and slider on the same line-->
<script type="module">
    /**
     * Clean Architecture Implementation for Crypto Chart
     *
     * Following Clean Architecture principles:
     * - Utils: Pure utility functions
     * - Domain: Business logic and data processing
     * - UI: Presentation and user interaction
     * - Services: External communication
     * - Controller: Orchestration
     */

    /**
     * @typedef {Object} PriceDataPoint
     * @property {string} timestamp - ISO timestamp string
     * @property {number} price - Price value
     */

    /**
     * @typedef {Object} ExtremaPoint
     * @property {string} timestamp - ISO timestamp string
     * @property {number} price - Price value
     * @property {('top'|'bottom')} type - Type of extrema point
     * @property {number} [significance] - Calculated significance value
     */

    /**
     * @typedef {Object} ChartParams
     * @property {string} symbol - Trading pair symbol (e.g., "BTCUSDT")
     * @property {string} interval - Time interval (e.g., "1h", "4h")
     * @property {number} limit - Number of data points to fetch
     * @property {number} threshold - Precision threshold value
     */

    /**
     * @typedef {Object} ThresholdRange
     * @property {number} min - Minimum threshold value
     * @property {number} max - Maximum threshold value
     * @property {number} step - Step size for threshold slider
     */

    /**
     * @typedef {Object} ChartData
     * @property {PriceDataPoint[]} filteredData - Filtered data points
     * @property {ExtremaPoint[]} extremaPoints - Extrema points
     */

    /**
     * @typedef {Object} PriceRange
     * @property {number} topY - Top Y coordinate
     * @property {number} bottomY - Bottom Y coordinate
     * @property {number} topPrice - Top price value
     * @property {number} bottomPrice - Bottom price value
     * @property {number} height - Range height
     * @property {number} percentDiff - Percentage difference
     */

    /**
     * @typedef {Object} Dimensions
     * @property {number} width - Chart width in pixels
     * @property {number} height - Chart height in pixels
     * @property {Object} margin - Chart margins
     * @property {number} margin.top - Top margin
     * @property {number} margin.right - Right margin
     * @property {number} margin.bottom - Bottom margin
     * @property {number} margin.left - Left margin
     */

        // ===================================================
        // UTILITIES - Pure utility functions
        // ===================================================
    const ChartUtils = {
            /**
             * Format price for display based on magnitude
             * @param {number} price - The price to format
             * @param {number} [customDecimals] - Optional custom decimal places
             * @returns {string} Formatted price
             */
            formatPrice(price, customDecimals) {
                const magnitude = price > 0 ? Math.pow(10, Math.floor(Math.log10(price))) : 1;

                let decimals = customDecimals;
                if (decimals === undefined) {
                    decimals = 2;
                    if (magnitude < 1) decimals = 4;
                    else if (magnitude < 10) decimals = 3;
                    else if (magnitude < 100) decimals = 2;
                    else decimals = 0;
                }

                return `${price.toFixed(decimals)}`;
            },

            /**
             * Calculate the ideal threshold slider range based on price
             * @param {number} lastPrice - The latest price value
             * @returns {ThresholdRange} Range settings for threshold slider
             */
            calculateThresholdRange(lastPrice) {
                const magnitude = lastPrice > 0 ? Math.pow(10, Math.ceil(Math.log10(lastPrice))) : 10;
                return {
                    min: 0,
                    max: magnitude * 0.20,
                    step: magnitude * 0.001
                };
            },

            /**
             * Format date for display
             * @param {Date} date - Date to format
             * @returns {string} Formatted date string
             */
            formatDate(date) {
                return d3.timeFormat("%d %b %H:%M")(date);
            },

            /**
             * Calculate percentage difference between two prices
             * @param {number} price1 - First price
             * @param {number} price2 - Second price
             * @returns {number} Percentage difference
             */
            calculatePercentDifference(price1, price2) {
                if (price2 === 0) return 0;
                return ((price1 - price2) / price2) * 100;
            },

            /**
             * Format percentage with +/- sign
             * @param {number} percent - Percentage value
             * @param {number} [decimals=2] - Number of decimal places
             * @returns {string} Formatted percentage
             */
            formatPercent(percent, decimals = 2) {
                return `${percent >= 0 ? '+' : ''}${percent.toFixed(decimals)}%`;
            }
        };

    // ===================================================
    // DOMAIN - Business logic and data processing
    // ===================================================
    /**
     * Handles data processing and analysis
     */
    class DataProcessor {
        /**
         * Apply precision filtering to data based on threshold
         * @param {PriceDataPoint[]} data - Array of price data points
         * @param {number} thresholdUSDT - Price change threshold
         * @returns {PriceDataPoint[]} Filtered data points
         */
        static applyPrecisionFilter(data, thresholdUSDT) {
            if (thresholdUSDT <= 0 || data.length <= 1) return [...data]; // Return a copy

            const filteredData = [data[0]];
            let lastIncludedPoint = data[0];

            for (let i = 1; i < data.length; i++) {
                const currentPoint = data[i];
                const priceChange = Math.abs(currentPoint.price - lastIncludedPoint.price);

                if (priceChange >= thresholdUSDT || i === data.length - 1) {
                    filteredData.push(currentPoint);
                    lastIncludedPoint = currentPoint;
                }
            }

            return filteredData;
        }

        /**
         * Find local extrema points (tops and bottoms)
         * @param {PriceDataPoint[]} data - Array of price data points
         * @returns {ExtremaPoint[]} Array of local extrema points
         */
        static findLocalExtrema(data) {
            if (data.length < 3) return [];

            /** @type {ExtremaPoint[]} */
            const extrema = [];

            // Process middle points
            for (let i = 1; i < data.length - 1; i++) {
                const prev = data[i - 1].price;
                const current = data[i].price;
                const next = data[i + 1].price;

                if (current > prev && current > next) {
                    extrema.push({timestamp: data[i].timestamp, price: current, type: 'top'});
                } else if (current < prev && current < next) {
                    extrema.push({timestamp: data[i].timestamp, price: current, type: 'bottom'});
                }
            }

            // Include first point if it's a local extrema
            if (data.length > 1) {
                const firstPoint = data[0];
                const secondPoint = data[1];
                const type = firstPoint.price < secondPoint.price ? 'bottom' : 'top';
                extrema.push({timestamp: firstPoint.timestamp, price: firstPoint.price, type});
            }

            return DataProcessor.filterExtrema(extrema, data);
        }

        /**
         * Filter extrema points to avoid overcrowding
         * @param {ExtremaPoint[]} extrema - Array of extrema points
         * @param {PriceDataPoint[]} data - Array of price data points
         * @returns {ExtremaPoint[]} Filtered extrema points
         * @private
         */
        static filterExtrema(extrema, data) {
            if (extrema.length <= 5) return [...extrema]; // Return a copy

            // Calculate price range for significance normalization
            const priceRange = d3.max(data, d => d.price) - d3.min(data, d => d.price);
            if (priceRange === 0) return [];

            // Calculate significance for each extrema point
            const extremaWithSignificance = extrema.map(point => {
                const oppositeType = point.type === 'top' ? 'bottom' : 'top';

                // Find nearest extrema of opposite type
                const oppositeExtrema = extrema
                    .filter(e => e.type === oppositeType)
                    .sort((a, b) => Math.abs(new Date(a.timestamp) - new Date(point.timestamp)) -
                        Math.abs(new Date(b.timestamp) - new Date(point.timestamp)));

                const significance = oppositeExtrema.length > 0
                    ? Math.abs(point.price - oppositeExtrema[0].price) / priceRange
                    : 0.2; // Default significance

                return {...point, significance};
            });

            // Return most significant points
            return extremaWithSignificance
                .sort((a, b) => b.significance - a.significance)
                .slice(0, Math.min(8, extremaWithSignificance.length));
        }
    }


    // ===================================================
    // MODEL - Data management
    // ===================================================
    /**
     * Model for chart data and parameters
     */
    class ChartModel {
        /**
         * Creates a chart data model
         */
        constructor() {
            /** @type {PriceDataPoint[]} Raw unfiltered data from API */
            this.rawData = [];

            /** @type {ChartParams} Chart parameters */
            this.params = {
                symbol: 'BTCUSDT',
                interval: '1h',
                limit: 100,
                threshold: 0
            };

            /** @type {ThresholdRange} Threshold slider configuration */
            this.thresholdRange = {
                min: 0,
                max: 1000,
                step: 1
            };
        }

        /**
         * Update model parameters
         * @param {Partial<ChartParams>} params - Parameters to update
         * @returns {ChartParams} Updated parameters
         */
        setParams(params) {
            this.params = {...this.params, ...params};
            return this.getParams();
        }

        /**
         * Get current parameters
         * @returns {ChartParams} Current chart parameters
         */
        getParams() {
            return {...this.params};
        }

        /**
         * Get threshold range values
         * @returns {ThresholdRange} Current threshold range settings
         */
        getThresholdRange() {
            return {...this.thresholdRange};
        }

        /**
         * Update threshold range
         * @param {Partial<ThresholdRange>} range - Range values to update
         * @returns {ThresholdRange} Updated threshold range
         */
        updateThresholdRange(range) {
            this.thresholdRange = {...this.thresholdRange, ...range};
            return this.getThresholdRange();
        }

        /**
         * Apply filtering to data based on threshold
         * @param {PriceDataPoint[]} data - Raw data to filter
         * @param {number} threshold - Threshold value
         * @returns {PriceDataPoint[]} Filtered data points
         */
        filterData(data, threshold) {
            return DataProcessor.applyPrecisionFilter(data, threshold);
        }

        /**
         * Process data for chart display
         * @returns {ChartData} Processed data
         */
        processData() {
            const filteredData = this.filterData(this.rawData, this.params.threshold);
            const extremaPoints = DataProcessor.findLocalExtrema(filteredData);

            return {filteredData, extremaPoints};
        }

        /**
         * Get the last price from data
         * @param {PriceDataPoint[]} data - Price data
         * @returns {number|null} Last price or null if data is empty
         */
        getLastPrice(data) {
            if (data.length === 0) return null;
            return data[data.length - 1].price;
        }

        /**
         * Fetch data from the API
         * @returns {Promise<ChartData>} Processed data
         * @throws {Error} If API request fails
         */
        async fetchData() {
            try {
                const {symbol, interval, limit} = this.params;
                this.rawData = await ApiService.fetchPriceData(symbol, interval, limit);
                return this.processData();
            } catch (error) {
                console.error('Error fetching data:', error);
                throw error;
            }
        }
    }

    // ===================================================
    // VIEW COMPONENTS - UI building blocks
    // ===================================================
    /**
     * Component for displaying price guide
     */
    class PriceGuideComponent {
        /**
         * Create a price guide component
         * @param {HTMLElement} container - Parent container
         * @param {object} chartInfo - Chart scales and margins
         */
        constructor(container, chartInfo) {
            this.container = container;
            this.chartInfo = chartInfo;

            // Initialize elements
            this.priceGuide = document.getElementById('price-guide');
            this.priceGuideLine = this.priceGuide.querySelector('.price-guide-line');
            this.priceGuideLabel = this.priceGuide.querySelector('.price-guide-label');
            this.priceGuidePercent = this.priceGuide.querySelector('.price-guide-percent');
        }

        /**
         * Update the chart info reference when scales change
         * @param {object} chartInfo - New chart scales and margins
         */
        updateChartInfo(chartInfo) {
            this.chartInfo = chartInfo;
        }

        /**
         * Update the price guide position and content
         * @param {number} y - Y position in pixels
         * @param {PriceDataPoint[]} currentData - Current chart data
         * @returns {Object} State of price guide
         */
        update(y, currentData) {
            const hoveredPrice = this._calculatePriceAtPosition(y);

            // Update DOM
            this.priceGuide.style.top = `${y}px`;
            this.priceGuide.style.opacity = '1';
            this.priceGuideLabel.textContent = ChartUtils.formatPrice(hoveredPrice);

            // Update percentage difference
            const lastPrice = currentData.length > 0 ? currentData[currentData.length - 1].price : null;
            if (lastPrice !== null) {
                const percentDiff = ChartUtils.calculatePercentDifference(hoveredPrice, lastPrice);
                const formattedPercent = ChartUtils.formatPercent(percentDiff);
                const color = percentDiff >= 0 ? '#4caf50' : '#ff5252';

                this.priceGuidePercent.textContent = formattedPercent;
                this.priceGuidePercent.style.backgroundColor = color;
            } else {
                this.priceGuidePercent.textContent = '';
            }

            return {
                y,
                hoveredPrice,
                lastPrice,
                visible: true
            };
        }

        /**
         * Hide the price guide
         * @returns {Object} State of price guide
         */
        hide() {
            this.priceGuide.style.opacity = '0';
            this.priceGuidePercent.textContent = '';

            return {
                visible: false
            };
        }

        /**
         * Calculate price at position
         * @param {number} y - Y position in pixels
         * @returns {number} Price at position
         * @private
         */
        _calculatePriceAtPosition(y) {
            const mouseYInScaleSpace = y - this.chartInfo.margin.top;
            return this.chartInfo.y.invert(mouseYInScaleSpace);
        }
    }

    /**
     * Component for price range selection
     */
    class PriceRangeComponent {
        /**
         * Create a price range selection component
         * @param {HTMLElement} container - Parent container
         * @param {object} chartInfo - Chart scales and margins
         */
        constructor(container, chartInfo) {
            this.container = container;
            this.chartInfo = chartInfo;

            // Create elements
            this.rangeZone = document.createElement('div');
            this.rangeZone.className = 'price-range-zone';
            this.rangeZone.style.display = 'none';
            container.appendChild(this.rangeZone);

            this.topLabel = document.createElement('div');
            this.topLabel.className = 'price-range-label';
            container.appendChild(this.topLabel);

            this.bottomLabel = document.createElement('div');
            this.bottomLabel.className = 'price-range-label';
            container.appendChild(this.bottomLabel);

            // Drag state
            this.dragState = {
                isDragging: false,
                startY: 0,
                endY: 0
            };
        }

        /**
         * Update the chart info reference when scales change
         * @param {object} chartInfo - New chart scales and margins
         */
        updateChartInfo(chartInfo) {
            this.chartInfo = chartInfo;
        }

        /**
         * Start dragging operation
         * @param {number} y - Starting Y position
         * @returns {Object} Drag state
         */
        startDrag(y) {
            this.dragState = {
                isDragging: true,
                startY: y,
                endY: y
            };

            return {...this.dragState};
        }

        /**
         * Update dragging position
         * @param {number} y - Current Y position
         * @returns {PriceRange|null} Price range info or null if not dragging
         */
        updateDrag(y) {
            if (!this.dragState.isDragging) return null;

            this.dragState.endY = y;
            const priceRange = this._calculatePriceRange();
            this._updateDisplay(priceRange);

            return priceRange;
        }

        /**
         * End dragging operation
         * @returns {Object} Results of the drag operation
         */
        endDrag() {
            if (!this.dragState.isDragging) {
                return {isSignificantDrag: false, dragState: {...this.dragState}};
            }

            const isSignificantDrag = Math.abs(this.dragState.endY - this.dragState.startY) >= 5;

            if (!isSignificantDrag) {
                this.clear();
            }

            const result = {
                isSignificantDrag,
                dragState: {...this.dragState}
            };

            this.dragState.isDragging = false;

            return result;
        }

        /**
         * Calculate price range based on current drag state
         * @returns {PriceRange} Price range info
         * @private
         */
        _calculatePriceRange() {
            const topY = Math.min(this.dragState.startY, this.dragState.endY);
            const bottomY = Math.max(this.dragState.startY, this.dragState.endY);
            const height = bottomY - topY;

            // Calculate prices from Y positions
            const topYInScale = topY - this.chartInfo.margin.top;
            const bottomYInScale = bottomY - this.chartInfo.margin.top;
            const topPrice = this.chartInfo.y.invert(topYInScale);
            const bottomPrice = this.chartInfo.y.invert(bottomYInScale);

            // Calculate percentage difference
            const priceDiff = Math.abs(topPrice - bottomPrice);
            const percentDiff = (priceDiff / bottomPrice) * 100;

            return {
                topY,
                bottomY,
                topPrice,
                bottomPrice,
                height,
                percentDiff
            };
        }

        /**
         * Update the display based on price range
         * @param {PriceRange} priceRange - Price range info
         * @private
         */
        _updateDisplay(priceRange) {
            const {topY, bottomY, topPrice, bottomPrice, height, percentDiff} = priceRange;

            // Update zone
            this.rangeZone.style.display = 'block';
            this.rangeZone.style.top = `${topY}px`;
            this.rangeZone.style.height = `${height}px`;

            // Update labels
            this.topLabel.style.display = 'block';
            this.topLabel.style.top = `${topY}px`;
            this.topLabel.textContent = ChartUtils.formatPrice(topPrice);

            this.bottomLabel.style.display = 'block';
            this.bottomLabel.style.top = `${bottomY}px`;
            this.bottomLabel.textContent = ChartUtils.formatPrice(bottomPrice);

            // Add percentage info if enough space
            if (height > 30) {
                this.topLabel.textContent += ` (${percentDiff.toFixed(2)}%)`;
            }
        }

        /**
         * Clear the selection
         */
        clear() {
            this.rangeZone.style.display = 'none';
            this.topLabel.style.display = 'none';
            this.bottomLabel.style.display = 'none';
        }

        /**
         * Check if component is in dragging state
         * @returns {boolean} True if dragging
         */
        isDraggingActive() {
            return this.dragState.isDragging;
        }
    }

    /**
     * Component for chart controls
     */
    class ControlsComponent {
        /**
         * Create controls component
         */
        constructor() {
            // Initialize control elements
            this.limitSlider = /** @type {HTMLInputElement} */ (document.getElementById('limit-slider'));
            this.limitValue = document.getElementById('limit-value');
            this.precisionSlider = /** @type {HTMLInputElement} */ (document.getElementById('precision-slider'));
            this.precisionValue = document.getElementById('precision-value');
            this.refreshButton = /** @type {HTMLButtonElement} */ (document.getElementById('refresh'));

            // Initial values
            this.currentValues = {
                symbol: 'BTCUSDT',
                interval: '1h',
                limit: 100,
                threshold: 0
            };

            // Callbacks
            this.callbacks = {};
        }

        /**
         * Setup event listeners
         * @param {object} callbacks - Event callbacks
         */
        setupEventListeners(callbacks) {
            this.callbacks = {...callbacks};

            // Precision slider
            this.precisionSlider.addEventListener('input', () => {
                const value = parseFloat(this.precisionSlider.value);
                this.precisionValue.textContent = ChartUtils.formatPrice(value);

                if (this.callbacks.onThresholdChange) {
                    this.callbacks.onThresholdChange(value);
                }
            });

            this.precisionSlider.addEventListener('change', () => {
                if (this.callbacks.onThresholdSet) {
                    this.callbacks.onThresholdSet(parseFloat(this.precisionSlider.value));
                }
            });

            // Limit slider
            this.limitSlider.addEventListener('input', () => {
                this.limitValue.textContent = this.limitSlider.value;
            });

            this.limitSlider.addEventListener('change', () => {
                if (this.callbacks.onLimitChange) {
                    this.callbacks.onLimitChange(parseInt(this.limitSlider.value, 10));
                }
            });

            // Symbol radio buttons
            document.querySelectorAll('input[name="symbol"]').forEach(radio => {
                radio.addEventListener('change', () => {
                    if (this.callbacks.onSymbolChange) {
                        this.callbacks.onSymbolChange(radio.value);
                    }
                });
            });

            // Interval radio buttons
            document.querySelectorAll('input[name="interval"]').forEach(radio => {
                radio.addEventListener('change', () => {
                    if (this.callbacks.onIntervalChange) {
                        this.callbacks.onIntervalChange(radio.value);
                    }
                });
            });

            // Refresh button
            this.refreshButton.addEventListener('click', () => {
                if (this.callbacks.onRefresh) {
                    this.callbacks.onRefresh();
                }
            });
        }

        /**
         * Update control values based on params
         * @param {ChartParams} params - Chart parameters
         * @param {ThresholdRange} [thresholdRange] - Threshold range settings
         * @returns {Object} Current control values
         */
        updateControls(params, thresholdRange) {
            // Update radio buttons
            this._setRadioValue('symbol', params.symbol);
            this._setRadioValue('interval', params.interval);

            // Update sliders
            this.limitSlider.value = String(params.limit);
            this.limitValue.textContent = String(params.limit);

            // Update threshold slider properties if provided
            if (thresholdRange) {
                this.precisionSlider.min = String(thresholdRange.min);
                this.precisionSlider.max = String(thresholdRange.max);
                this.precisionSlider.step = String(thresholdRange.step);
            }

            // Update threshold value
            this.precisionSlider.value = String(params.threshold);
            this.precisionValue.textContent = ChartUtils.formatPrice(params.threshold);

            // Store current values
            this.currentValues = {...params};

            return {...this.currentValues};
        }

        /**
         * Set radio button value
         * @param {string} name - Radio group name
         * @param {string} value - Value to select
         * @private
         */
        _setRadioValue(name, value) {
            const radio = document.querySelector(`input[name="${name}"][value="${value}"]`);
            if (radio) {
                radio.checked = true;
            }
        }
    }

    // ===================================================
    // CHART RENDERER - D3 Rendering Logic - RESPONSIVE
    // ===================================================
    /**
     * Component for D3 chart rendering
     */
    class ChartRenderer {
        /**
         * Create a chart renderer
         * @param {HTMLElement} container - Chart container
         * @param {Dimensions} dimensions - Chart dimensions
         */
        constructor(container, dimensions) {
            this.container = container;
            this.dimensions = dimensions;

            /** @type {PriceDataPoint[]} Store last rendered data */
            this.lastData = [];

            /** @type {ExtremaPoint[]} Store last rendered extrema points */
            this.lastExtremaPoints = [];

            // Initialize D3 elements
            this._initializeChart();
        }

        /**
         * Initialize D3 chart components
         * @private
         */
        _initializeChart() {
            const {width, height, margin} = this.dimensions;

            // Create SVG container with viewBox for responsiveness
            this.svg = d3.select(this.container)
                .append('svg')
                .attr('width', '100%')
                .attr('height', height + margin.top + margin.bottom)
                .attr('viewBox', `0 0 ${width + margin.left + margin.right} ${height + margin.top + margin.bottom}`)
                .attr('preserveAspectRatio', 'xMidYMid meet')
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            // Create clipping path
            this.svg.append("defs")
                .append("clipPath")
                .attr("id", "chart-area-clip")
                .append("rect")
                .attr("width", width)
                .attr("height", height)
                .attr("x", 0)
                .attr("y", 0);

            // Create a group for chart content that will be clipped
            this.chartGroup = this.svg.append('g')
                .attr('clip-path', 'url(#chart-area-clip)');

            // Create scales
            this.x = d3.scaleTime().range([0, width]);
            this.y = d3.scaleLinear().range([height, 0]);

            // Create generators
            this.lineGenerator = d3.line()
                .x(d => this.x(new Date(d.timestamp)))
                .y(d => this.y(d.price))
                .curve(d3.curveStepAfter);

            this.areaGenerator = d3.area()
                .x(d => this.x(new Date(d.timestamp)))
                .y0(height)
                .y1(d => this.y(d.price))
                .curve(d3.curveStepAfter);

            // Create axes
            this.xAxis = this.svg.append('g')
                .attr('class', 'x axis')
                .attr('transform', `translate(0,${height})`);

            this.yAxis = this.svg.append('g')
                .attr('class', 'y axis');

            // Create grid lines
            this.xGrid = this.chartGroup.append('g')
                .attr('class', 'grid x-grid');

            this.yGrid = this.chartGroup.append('g')
                .attr('class', 'grid y-grid');

            // Add labels
            this.dateRangeLabel = this.svg.append('text')
                .attr('class', 'date-range-label')
                .attr('text-anchor', 'middle')
                .attr('transform', `translate(${width / 2},-10)`)
                .style('font-size', '12px')
                .style('fill', '#666')
                .text('Loading date range...');

            // Add Y axis label
            this.svg.append('text')
                .attr('text-anchor', 'middle')
                .attr('transform', `rotate(-90) translate(${-height / 2},${-margin.left + 15})`)
                .style('font-size', '14px')
                .text('Price (USDT)');

            // Add chart elements
            this.path = this.chartGroup.append('path').attr('class', 'line');
            this.areaPath = this.chartGroup.append('path').attr('class', 'area');

            // Add current price indicators
            this.currentPriceLine = this.chartGroup.append('line')
                .attr('stroke', '#3498db')
                .attr('stroke-width', 1)
                .attr('stroke-dasharray', '5,3');

            this.currentPriceBullet = this.chartGroup.append('circle')
                .attr('r', 6)
                .attr('fill', '#3498db')
                .attr('stroke', 'white')
                .attr('stroke-width', 1);
        }

        /**
         * Resize the chart and fully redraw all elements
         * @param {Dimensions} dimensions - New dimensions
         */
        resize(dimensions) {
            // Update internal dimensions
            this.dimensions = dimensions;
            const {width, height, margin} = dimensions;

            // Update SVG viewBox
            d3.select(this.container).select('svg')
                .attr('viewBox', `0 0 ${width + margin.left + margin.right} ${height + margin.top + margin.bottom}`);

            // Update clipPath
            this.svg.select("#chart-area-clip rect")
                .attr("width", width)
                .attr("height", height);

            // Update scales ranges
            this.x.range([0, width]);
            this.y.range([height, 0]);

            // Update axes positions
            this.xAxis.attr('transform', `translate(0,${height})`);

            // Update generators
            this.areaGenerator.y0(height);

            // Update labels
            this.dateRangeLabel.attr('transform', `translate(${width / 2},-10)`);
            this.svg.select('text[transform^="rotate(-90)"]')
                .attr('transform', `rotate(-90) translate(${-height / 2},${-margin.left + 15})`);

            // Completely redraw the chart with stored data
            if (this.lastData && this.lastData.length > 0) {
                this.updateScales(this.lastData);
                this.updateAxes();
                this.updateChartLines(this.lastData);

                // Clear and redraw all extrema labels
                this.clearLabels();
                if (this.lastExtremaPoints && this.lastExtremaPoints.length > 0) {
                    this.renderExtremaPoints(this.lastExtremaPoints);
                }

                // Update current price indicator
                if (this.lastData.length > 0) {
                    this.updateCurrentPriceIndicator(this.lastData[this.lastData.length - 1]);
                }
            }
        }

        /**
         * Get D3 scales
         * @returns {{x: d3.ScaleTime, y: d3.ScaleLinear, margin: {top: number, right: number, bottom: number, left: number}}}
         *          D3 scales and margins
         */
        getScales() {
            return {
                x: this.x,
                y: this.y,
                margin: this.dimensions.margin
            };
        }

        /**
         * Update scales based on data
         * @param {PriceDataPoint[]} data - Chart data
         * @returns {{timeExtent: [Date, Date], priceExtent: [number, number]}} Scale extent information
         */
        updateScales(data) {
            // Store the data for potential resizing
            this.lastData = [...data];

            // Update date scale
            const timeExtent = d3.extent(data, d => new Date(d.timestamp));
            this.x.domain(timeExtent);

            // Update date range label
            const startDate = timeExtent[0];
            const endDate = timeExtent[1];
            const dateRangeText = `${ChartUtils.formatDate(startDate)} - ${ChartUtils.formatDate(endDate)}`;
            this.dateRangeLabel.text(dateRangeText);

            // Calculate price range with padding
            const minPrice = d3.min(data, d => d.price);
            const maxPrice = d3.max(data, d => d.price);
            const padding = (maxPrice - minPrice) * 0.05;
            this.y.domain([minPrice - padding, maxPrice + padding]);

            return {timeExtent, priceExtent: [minPrice, maxPrice]};
        }

        /**
         * Update axes with current scales, adapting to screen size
         */
        updateAxes() {
            const {width} = this.dimensions;

            // Calculate number of ticks based on width
            const xTickCount = this._calculateTickCount(width);
            const yTickCount = this._calculateTickCount(width, 0.6);

            // Update X axis with adaptive ticks
            this.xAxis.call(
                d3.axisBottom(this.x)
                    .ticks(xTickCount)
                    .tickFormat(d => {
                        // For small screens, simplify the date format
                        if (width < 500) {
                            return d3.timeFormat("%d/%m")(d);
                        }
                        return d3.timeFormat("%b %d %H:%M")(d);
                    })
            );

            // Update Y axis with adaptive ticks
            this.yAxis.call(
                d3.axisLeft(this.y)
                    .ticks(yTickCount)
                    .tickFormat(d => {
                        // Simplify numbers on small screens
                        if (width < 500) {
                            if (d >= 1000) {
                                return `${(d / 1000).toFixed(1)}K`;
                            }
                            return d.toFixed(0);
                        }
                        return `${d.toLocaleString()}`;
                    })
            );

            // Update grid lines
            this.xGrid.call(
                d3.axisBottom(this.x)
                    .ticks(Math.max(5, xTickCount))
                    .tickSize(-this.dimensions.height)
                    .tickFormat('')
            );

            this.yGrid.call(
                d3.axisLeft(this.y)
                    .ticks(Math.max(5, yTickCount))
                    .tickSize(-this.dimensions.width)
                    .tickFormat('')
            );
        }

        /**
         * Calculate appropriate tick count based on width
         * @param {number} width - Chart width
         * @param {number} [factor=1] - Adjustment factor
         * @returns {number} - Appropriate tick count
         * @private
         */
        _calculateTickCount(width, factor = 1) {
            // Base calculation for ticks
            let tickCount = Math.floor(width / 100) * factor;

            // Ensure reasonable limits
            tickCount = Math.max(3, Math.min(10, tickCount));

            return tickCount;
        }

        /**
         * Clear existing chart labels
         */
        clearLabels() {
            this.svg.selectAll('.extrema-label').remove();
            this.svg.selectAll('.data-point').remove();
        }

        /**
         * Update chart lines and areas
         * @param {PriceDataPoint[]} data - Chart data
         */
        updateChartLines(data) {
            this.path.datum(data).attr('d', this.lineGenerator);
            this.areaPath.datum(data).attr('d', this.areaGenerator);
        }

        /**
         * Update current price indicator
         * @param {PriceDataPoint} lastPoint - Last price data point
         * @returns {{x: number, y: number, price: number}} Position information
         */
        updateCurrentPriceIndicator(lastPoint) {
            const lastX = this.x(new Date(lastPoint.timestamp));
            const lastY = this.y(lastPoint.price);

            // Update horizontal line at current price
            this.currentPriceLine
                .attr('x1', 0)
                .attr('x2', this.dimensions.width)
                .attr('y1', lastY)
                .attr('y2', lastY);

            // Update bullet point
            this.currentPriceBullet
                .attr('cx', lastX)
                .attr('cy', lastY);

            // Ensure price indicators are drawn on top
            this.svg.node().appendChild(this.currentPriceLine.node());
            this.svg.node().appendChild(this.currentPriceBullet.node());

            return {x: lastX, y: lastY, price: lastPoint.price};
        }

        /**
         * Render extrema points on chart
         * @param {ExtremaPoint[]} extremaPoints - Extrema points to render
         */
        renderExtremaPoints(extremaPoints) {
            // Store extrema points for redrawing on resize
            this.lastExtremaPoints = [...extremaPoints];

            // Get chart width to adapt label size
            const {width} = this.dimensions;
            const isSmallScreen = width < 600;

            // Adjust label size for small screens
            const labelWidth = isSmallScreen ? 44 : 60;
            const labelHeight = isSmallScreen ? 16 : 20;
            const fontSize = isSmallScreen ? '9px' : '11px';

            extremaPoints.forEach(point => {
                const pointX = this.x(new Date(point.timestamp));
                const pointY = this.y(point.price);
                const isTop = point.type === 'top';
                const color = isTop ? '#4caf50' : '#ff5252';

                // Background rectangle
                this.svg.append('rect')
                    .attr('class', 'extrema-label')
                    .attr('x', pointX - labelWidth / 2)
                    .attr('y', isTop ? pointY - labelHeight - 5 : pointY + 5)
                    .attr('width', labelWidth)
                    .attr('height', labelHeight)
                    .attr('rx', 3)
                    .attr('ry', 3)
                    .attr('fill', color)
                    .attr('opacity', 0.85);

                // Price text
                this.svg.append('text')
                    .attr('class', 'extrema-label')
                    .attr('x', pointX)
                    .attr('y', isTop ? pointY - labelHeight + 9 : pointY + labelHeight - 5)
                    .attr('text-anchor', 'middle')
                    .attr('fill', 'white')
                    .attr('font-size', fontSize)
                    .attr('font-weight', 'bold')
                    .text(this._formatExtremaPrice(point.price, isSmallScreen));
            });
        }

        /**
         * Format price for extrema labels, adapting to screen size
         * @param {number} price - Price to format
         * @param {boolean} isSmallScreen - If true, use compact notation
         * @returns {string} Formatted price
         * @private
         */
        _formatExtremaPrice(price, isSmallScreen) {
            if (isSmallScreen) {
                // For small screens, use compact notation
                if (price >= 1000) {
                    return `${(price / 1000).toFixed(1)}K`;
                }
                return price.toFixed(0);
            }

            // For larger screens, use locale string with limited decimals
            return price.toLocaleString(undefined, {maximumFractionDigits: 0});
        }
    }

    // ===================================================
    // VIEW - Chart visualization - RESPONSIVE
    // ===================================================
    /**
     * Main chart view
     */
    class ChartView {
        /**
         * Creates a chart view
         * @param {string} containerId - Chart container ID
         */
        constructor(containerId) {
            /** @type {HTMLElement} Main chart container */
            this.container = document.getElementById(containerId);

            /** @type {HTMLElement} Chart title element */
            this.chartTitle = document.getElementById('chart-title');

            /** @type {HTMLElement} Loading indicator */
            this.loadingEl = document.getElementById('loading');

            /** @type {HTMLElement} Current price label */
            this.currentPriceLabel = document.getElementById('current-price-label');

            // Chart configuration
            /** @type {{top: number, right: number, bottom: number, left: number}} */
            this.margin = {top: 20, right: 50, bottom: 50, left: 70};

            // Calculate initial dimensions based on container
            this._calculateDimensions();

            // Initialize chart renderer
            this.renderer = new ChartRenderer(this.container, {
                width: this.width,
                height: this.height,
                margin: this.margin
            });

            // Get scales from renderer
            const scales = this.renderer.getScales();

            // Initialize UI components
            this.priceGuide = new PriceGuideComponent(this.container, scales);
            this.priceRange = new PriceRangeComponent(this.container, scales);
            this.controls = new ControlsComponent();

            // Store current data
            /** @type {PriceDataPoint[]} */
            this.currentData = [];

            // Debounce resize handler to improve performance
            this._debouncedResize = this._debounce(this._handleResize.bind(this), 150);

            // Add resize event listener
            window.addEventListener('resize', this._debouncedResize);
        }

        /**
         * Debounce function to limit resize events
         * @param {Function} func - Function to debounce
         * @param {number} wait - Milliseconds to wait
         * @returns {Function} Debounced function
         * @private
         */
        _debounce(func, wait) {
            let timeout;
            return function () {
                const context = this;
                const args = arguments;
                clearTimeout(timeout);
                timeout = setTimeout(() => {
                    func.apply(context, args);
                }, wait);
            };
        }

        /**
         * Calculate dimensions based on container width
         * @private
         */
        _calculateDimensions() {
            // Get the actual container width
            const containerWidth = this.container.clientWidth;

            /** @type {number} Chart width */
            this.width = Math.max(300, containerWidth - this.margin.left - this.margin.right);

            /** @type {number} Chart height */
            // Maintain aspect ratio or use fixed height
            this.height = Math.max(200, Math.min(500, Math.round(this.width * 0.5)) - this.margin.top - this.margin.bottom);

            // On very small screens, adjust left margin for axis labels
            if (containerWidth < 400) {
                this.margin.left = 50; // Smaller margin
            } else {
                this.margin.left = 70; // Default margin
            }
        }

        /**
         * Handle window resize events
         * @private
         */
        _handleResize() {
            // Recalculate dimensions
            this._calculateDimensions();

            // Resize the renderer
            this.renderer.resize({
                width: this.width,
                height: this.height,
                margin: this.margin
            });

            // Update UI components with new scale info
            const scales = this.renderer.getScales();
            this.priceGuide.updateChartInfo(scales);
            this.priceRange.updateChartInfo(scales);

            // Reposition current price label if it exists
            if (this.currentData.length > 0) {
                const lastPoint = this.currentData[this.currentData.length - 1];
                const currentPriceInfo = this.renderer.updateCurrentPriceIndicator(lastPoint);
                this.currentPriceLabel.style.top = `${currentPriceInfo.y + this.margin.top - 10}px`;
            }
        }

        /**
         * Set up event listeners
         * @param {object} callbacks - Callback functions for events
         */
        setupEventListeners(callbacks) {
            // Setup controls component listeners
            this.controls.setupEventListeners({
                onSymbolChange: callbacks.onSymbolChange,
                onIntervalChange: callbacks.onIntervalChange,
                onLimitChange: callbacks.onLimitChange,
                onThresholdChange: callbacks.onThresholdChange,
                onThresholdSet: callbacks.onThresholdSet,
                onRefresh: callbacks.onRefresh
            });

            // Mouse tracking for price guide
            this.container.addEventListener('mousemove', this.handleMouseMove.bind(this));
            this.container.addEventListener('mouseleave', () => this.priceGuide.hide());

            // Add drag selection handlers
            this.container.addEventListener('mousedown', this.handleMouseDown.bind(this));
            this.container.addEventListener('mousemove', this.handleDragMove.bind(this));
            this.container.addEventListener('mouseup', this.handleMouseUp.bind(this));

            // Add click handler to clear selection
            this.container.addEventListener('click', this.handleClick.bind(this));

            // Handle back/forward navigation
            window.addEventListener('popstate', () => {
                if (callbacks.onPopState) {
                    callbacks.onPopState();
                }
            });
        }

        /**
         * Handle mouse movement
         * @param {MouseEvent} event - Mouse event
         */
        handleMouseMove(event) {
            const chartRect = this.container.getBoundingClientRect();
            const relativeY = event.clientY - chartRect.top;

            if (this._isInChartArea(relativeY)) {
                this.priceGuide.update(relativeY, this.currentData);
            } else {
                this.priceGuide.hide();
            }

            // If we're dragging, don't interfere with the drag operation
            if (this.priceRange.isDraggingActive()) {
                event.preventDefault();
                event.stopPropagation();
            }
        }

        /**
         * Handle mouse down for drag selection
         * @param {MouseEvent} event - Mouse event
         */
        handleMouseDown(event) {
            const chartRect = this.container.getBoundingClientRect();
            const relativeY = event.clientY - chartRect.top;

            // Only start dragging if within chart area
            if (this._isInChartArea(relativeY)) {
                this.priceRange.startDrag(relativeY);
                this.priceGuide.hide();
            }
        }

        /**
         * Handle mouse move while dragging
         * @param {MouseEvent} event - Mouse event
         */
        handleDragMove(event) {
            if (!this.priceRange.isDraggingActive()) return;

            const chartRect = this.container.getBoundingClientRect();
            const relativeY = Math.max(
                this.margin.top,
                Math.min(event.clientY - chartRect.top, chartRect.height - this.margin.bottom)
            );

            this.priceRange.updateDrag(relativeY);
        }

        /**
         * Handle mouse up for drag selection
         * @param {MouseEvent} event - Mouse event
         */
        handleMouseUp(event) {
            this.priceRange.endDrag();
        }

        /**
         * Handle click to clear selection
         * @param {MouseEvent} event - Mouse event
         */
        handleClick(event) {
            // Clear the selection if not dragging
            if (!this.priceRange.isDraggingActive()) {
                this.priceRange.clear();
            }
        }

        /**
         * Check if position is in chart area
         * @param {number} y - Y coordinate
         * @returns {boolean} True if in chart area
         * @private
         */
        _isInChartArea(y) {
            const chartRect = this.container.getBoundingClientRect();
            return y >= this.margin.top && y <= (chartRect.height - this.margin.bottom);
        }

        /**
         * Update chart title based on parameters
         * @param {ChartParams} params - Chart parameters
         * @returns {string} Updated title
         */
        updateChartTitle(params) {
            const symbolDisplay = params.symbol.replace('USDT', '');
            const title = `${symbolDisplay} ${params.interval} Chart`;
            this.chartTitle.textContent = title;
            return title;
        }

        /**
         * Update UI controls based on parameters
         * @param {ChartParams} params - Chart parameters
         * @param {ThresholdRange} [thresholdRange] - Optional threshold range settings
         * @returns {Object} Current control values
         */
        updateControls(params, thresholdRange) {
            return this.controls.updateControls(params, thresholdRange);
        }

        /**
         * Show loading indicator
         * @param {string} [message] - Optional loading message
         */
        showLoading(message = 'Loading data...') {
            this.loadingEl.style.display = 'block';
            this.loadingEl.textContent = message;
        }

        /**
         * Hide loading indicator
         */
        hideLoading() {
            this.loadingEl.style.display = 'none';
        }

        /**
         * Show error message
         * @param {string} [message] - Error message
         */
        showError(message) {
            this.loadingEl.style.display = 'block';
            this.loadingEl.textContent = message || 'Error loading data. Please try again.';
        }

        /**
         * Render the chart with data
         * @param {PriceDataPoint[]} data - Price data points to render
         * @param {ExtremaPoint[]} [extremaPoints] - Optional extrema points to highlight
         * @returns {Object} Rendering results
         */
        renderChart(data, extremaPoints) {
            if (data.length === 0) return {success: false, reason: 'No data'};

            // Store current data for hover percentage calculations
            this.currentData = [...data];

            // Update scales
            const scaleInfo = this.renderer.updateScales(data);

            // Update axes
            this.renderer.updateAxes();

            // Update line and area paths
            this.renderer.updateChartLines(data);

            // Clear existing extrema labels
            this.renderer.clearLabels();

            // Draw current price indicator
            const lastPoint = data[data.length - 1];
            const currentPriceInfo = this.renderer.updateCurrentPriceIndicator(lastPoint);

            // Update price label
            this.currentPriceLabel.style.display = 'block';
            this.currentPriceLabel.textContent = ChartUtils.formatPrice(lastPoint.price);
            this.currentPriceLabel.style.top = `${currentPriceInfo.y + this.margin.top - 10}px`;

            // Add extrema points
            if (extremaPoints && extremaPoints.length > 0) {
                this.renderer.renderExtremaPoints(extremaPoints);
            }

            // Clear any existing price range selection
            this.priceRange.clear();

            return {
                success: true,
                dataPoints: data.length,
                extremaPoints: extremaPoints ? extremaPoints.length : 0,
                scaleInfo,
                currentPrice: lastPoint.price
            };
        }
    }

    // ===================================================
    // Controller - App orchestration
    // ===================================================
    /**
     * Main controller for the chart application
     */
    class ChartController {
        /**
         * Creates a chart controller
         */
        constructor() {
            /** @type {ChartParams} Default settings */
            this.defaults = {
                symbol: 'BTCUSDT',
                interval: '1h',
                limit: 100,
                threshold: 0
            };

            /** @type {ChartModel} Data model */
            this.model = new ChartModel();

            /** @type {ChartView} UI view */
            this.view = new ChartView('chart-container');

            // Load initial state from URL
            this.loadFromUrl();

            // Setup event listeners
            this.setupEventListeners();

            // Initial chart render
            this.updateChart(true);
        }

        /**
         * Load settings from URL parameters
         * @returns {Object} Loaded parameters
         */
        loadFromUrl() {
            const {params, thresholdRange} = URLHandler.loadFromUrl(this.defaults);

            // Update model
            this.model.setParams(params);

            // Update threshold range if provided
            if (Object.keys(thresholdRange).length > 0) {
                this.model.updateThresholdRange(thresholdRange);
            }

            // Update view
            this.view.updateChartTitle(params);
            this.view.updateControls(params, this.model.getThresholdRange());

            return {params, thresholdRange};
        }

        /**
         * Set up event listeners
         */
        setupEventListeners() {
            this.view.setupEventListeners({
                onSymbolChange: this.handleSymbolChange.bind(this),
                onIntervalChange: this.handleIntervalChange.bind(this),
                onLimitChange: this.handleLimitChange.bind(this),
                onThresholdChange: this.handleThresholdChange.bind(this),
                onThresholdSet: this.handleThresholdSet.bind(this),
                onRefresh: this.handleRefresh.bind(this),
                onPopState: this.handlePopState.bind(this)
            });
        }

        /**
         * Handle symbol change
         * @param {string} symbol - New symbol value
         */
        handleSymbolChange(symbol) {
            const currentParams = this.model.getParams();
            if (currentParams.symbol === symbol) return;

            // Update model with new symbol and reset threshold
            const updatedParams = this.model.setParams({
                symbol,
                threshold: 0
            });

            // Update URL
            URLHandler.updateUrl(updatedParams, this.model.getThresholdRange());

            // Refresh chart
            this.updateChart(true);
        }

        /**
         * Handle interval change
         * @param {string} interval - New interval value
         */
        handleIntervalChange(interval) {
            const updatedParams = this.model.setParams({interval});
            URLHandler.updateUrl(updatedParams, this.model.getThresholdRange());
            this.updateChart(true);
        }

        /**
         * Handle limit change
         * @param {number} limit - New limit value
         */
        handleLimitChange(limit) {
            const updatedParams = this.model.setParams({limit});
            URLHandler.updateUrl(updatedParams, this.model.getThresholdRange());
            this.updateChart(true);
        }

        /**
         * Handle threshold slider change (live update)
         * @param {number} threshold - New threshold value
         */
        handleThresholdChange(threshold) {
            this.model.setParams({threshold});

            // Only update chart, don't update URL yet (wait for mouse release)
            if (this.model.rawData.length > 0) {
                const {filteredData, extremaPoints} = this.model.processData();
                this.view.renderChart(filteredData, extremaPoints);
            }
        }

        /**
         * Handle threshold slider set (after mouse release)
         * @param {number} threshold - Final threshold value
         */
        handleThresholdSet(threshold) {
            const updatedParams = this.model.setParams({threshold});
            URLHandler.updateUrl(updatedParams, this.model.getThresholdRange());
        }

        /**
         * Handle refresh button click
         */
        handleRefresh() {
            this.updateChart(true);
        }

        /**
         * Handle browser back/forward navigation
         */
        handlePopState() {
            this.loadFromUrl();
            this.updateChart(true);
        }

        /**
         * Calculate and update threshold slider based on price data
         * @param {PriceDataPoint[]} data - Price data points
         * @returns {ThresholdRange|null} New threshold range or null if data is empty
         */
        calculateThresholdRange(data) {
            if (data.length === 0) return null;

            const lastPrice = data[data.length - 1].price;
            const range = ChartUtils.calculateThresholdRange(lastPrice);

            return range;
        }

        /**
         * Fetch data and update chart
         * @param {boolean} [forceRefresh=false] - Force data refresh from API
         * @returns {Promise<Object>} Update results
         */
        async updateChart(forceRefresh = false) {
            // Update chart title
            const params = this.model.getParams();
            this.view.updateChartTitle(params);

            try {
                let chartData;

                // Show loading indicator for new data
                if (this.model.rawData.length === 0 || forceRefresh) {
                    this.view.showLoading();
                    chartData = await this.model.fetchData();
                } else {
                    // Use existing data
                    chartData = this.model.processData();
                }

                const {filteredData, extremaPoints} = chartData;

                // Update threshold slider based on data for new data
                if (forceRefresh && filteredData.length > 0) {
                    const newRange = this.calculateThresholdRange(filteredData);
                    if (newRange) {
                        this.model.updateThresholdRange(newRange);
                        this.view.updateControls(params, newRange);
                    }
                }

                // Hide loading and render chart
                this.view.hideLoading();
                const renderResult = this.view.renderChart(filteredData, extremaPoints);

                return {
                    success: true,
                    renderResult,
                    dataPoints: filteredData.length
                };
            } catch (error) {
                console.error('Error updating chart:', error);

                // Provide specific error messages based on error type
                let errorMessage = 'Error loading data. Please try again.';
                if (error.message.includes('API error')) {
                    errorMessage = 'Server error. Please try again later.';
                } else if (error.message.includes('network')) {
                    errorMessage = 'Network error. Please check your connection.';
                }

                this.view.showError(errorMessage);

                return {
                    success: false,
                    error: errorMessage,
                    originalError: error.message
                };
            }
        }
    }

    // Initialize the chart application
    document.addEventListener('DOMContentLoaded', () => {
        window.cryptoChart = new ChartController();
    });
</script>
</body>
</html>