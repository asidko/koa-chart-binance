<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crypto Price Chart</title>
    <link rel="icon" href="favicon.ico" type="image/x-icon">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Font Awesome for icons -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <!-- Chart Plugins -->
    <script src="chart-plugins/base.js"></script>
    <script src="chart-plugins/plugin-manager.js"></script>
    <script src="chart-plugins/price-line.js"></script>
    <script src="chart-plugins/current-price.js"></script>
    <script src="chart-plugins/price-range.js"></script>
    <script src="chart-plugins/price-guide.js"></script>
    <script src="chart-plugins/middle-line.js"></script>
    <script src="chart-plugins/movable-line.js"></script>
    <style>
        body {
            background-color: #f8f9fa;
        }

        /* Chart-specific styles */
        .chart-container {
            width: 100%;
            height: 500px;
            position: relative;
            background-color: white;
            border-radius: 0.25rem;
            overflow: hidden;
        }

        .line {
            fill: none;
            stroke: #ff9900;
            stroke-width: 2;
        }

        .area {
            fill: rgba(255, 153, 0, 0.1);
        }

        .axis {
            font-size: 12px;
        }

        .axis path, .axis line {
            fill: none;
            stroke: #ccc;
            shape-rendering: crispEdges;
        }

        .grid line {
            fill: none;
            stroke: #e0e0e0;
            shape-rendering: crispEdges;
        }

        .grid path {
            stroke-width: 0;
        }

        .loading {
            text-align: center;
            color: #6c757d;
            margin: 20px 0;
            font-style: italic;
        }

        /* Controls */
        .controls-panel {
            background-color: white;
            border-radius: 0.25rem;
            padding: 0.75rem;
            box-shadow: 0 .125rem .25rem rgba(0,0,0,.075);
        }

        .control-section {
            margin-bottom: 0.75rem;
        }

        .control-section:last-child {
            margin-bottom: 0;
        }

        .control-heading {
            font-weight: bold;
            display: inline-block;
            min-width: 60px;
            margin-right: 0.5rem;
        }

        .options-group {
            display: inline-flex;
            flex-wrap: wrap;
            gap: 0.75rem;
        }

        .options-group label {
            margin-bottom: 0;
            display: flex;
            align-items: center;
            cursor: pointer;
        }

        .options-group input {
            margin-right: 0.25rem;
        }

        /* Slider controls */
        .slider-controls {
            background-color: white;
            border-radius: 0.25rem;
            padding: 0.75rem;
            box-shadow: 0 .125rem .25rem rgba(0,0,0,.075);
        }

        .slider-row {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 0.5rem;
        }

        .slider-row:last-child {
            margin-bottom: 0;
        }

        .slider-row label {
            font-weight: bold;
            min-width: 60px;
            margin-bottom: 0;
        }

        .slider-row .slider {
            flex: 1;
        }

        .value-label {
            min-width: 2.5rem;
            text-align: center;
            background-color: #6c757d;
            color: white;
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
            font-size: 0.875rem;
        }

        /* Context Menu Styles */
        .context-menu {
            position: absolute;
            min-width: 150px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 3px 12px rgba(0, 0, 0, 0.15);
            padding: 4px 0;
            z-index: 1000;
            display: none;
        }

        .context-menu-item {
            padding: 6px 12px;
            display: flex;
            align-items: center;
            color: #333;
            cursor: pointer;
            transition: background-color 0.2s;
            font-size: 13px;
        }

        .context-menu-item:hover {
            background-color: #f0f0f0;
        }

        .context-menu-item i {
            margin-right: 8px;
            width: 16px;
            text-align: center;
            color: #666;
        }
        
        /* Responsive design for small screens */
        @media (max-width: 480px) {
            .control-heading {
                min-width: 50px;
                font-size: 12px;
            }
            
            .axis text {
                font-size: 9px;
            }
            
            .axis path, .axis line {
                stroke-width: 0.5px;
            }
            
            .options-group {
                gap: 0.5rem;
            }
            
            .slider-row label {
                min-width: 50px;
                font-size: 12px;
            }
        }
    </style>
</head>
<body>
<div class="container py-4">
    <h1 id="chart-title" class="text-center mb-3">BTC/USDT 1h Price Chart</h1>
    <div id="loading" class="loading">Loading data...</div>

    <!-- Simplified controls layout -->
    <div class="controls-panel mb-3">
        <div class="control-section">
            <label class="control-heading">Coins:</label>
            <div class="options-group">
                <label><input type="radio" name="symbol" value="BTCUSDT" checked> BTC</label>
                <label><input type="radio" name="symbol" value="ETHUSDT"> ETH</label>
                <label><input type="radio" name="symbol" value="XRPUSDT"> XRP</label>
                <label><input type="radio" name="symbol" value="SOLUSDT"> SOL</label>
                <label><input type="radio" name="symbol" value="BNBUSDT"> BNB</label>
                <label><input type="radio" name="symbol" value="TONUSDT"> TON</label>
            </div>
        </div>
        
        <div class="control-section">
            <label class="control-heading">Interval:</label>
            <div class="options-group">
                <label><input type="radio" name="interval" value="1h" checked> 1h</label>
                <label><input type="radio" name="interval" value="2h"> 2h</label>
                <label><input type="radio" name="interval" value="4h"> 4h</label>
                <label><input type="radio" name="interval" value="1d"> 1d</label>
                <label><input type="radio" name="interval" value="3d"> 3d</label>
            </div>
        </div>
    </div>

    <!-- Chart container simplified -->
    <div class="chart-container mb-3" id="chart-container">
        <!-- Chart plugins will add their UI elements here dynamically -->
    </div>

    <!-- Simplified sliders layout -->
    <div class="slider-controls mb-3">
        <div class="slider-row">
            <label for="limit-slider">Limit:</label>
            <input type="range" class="slider form-range" id="limit-slider" min="10" max="500" step="10" value="100">
            <span id="limit-value" class="value-label">100</span>
        </div>
        <div class="slider-row">
            <label for="precision-slider">Smooth:</label>
            <input type="range" class="slider form-range" id="precision-slider" min="0" max="1000" step="1" value="0">
            <span id="precision-value" class="value-label">$0</span>
        </div>
    </div>
    
    <!-- Context menu moved outside chart for cleaner separation -->
    <div id="chart-context-menu" class="context-menu">
        <div class="context-menu-item" data-action="refresh">
            <i class="fas fa-sync-alt"></i> Refresh Data
        </div>
    </div>
</div>

<!-- Bootstrap Bundle with Popper -->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
<script src="utils.js"></script>
<!-- Chart JavaScript code will go here -->
<script type="module">
    /**
     * Clean Architecture Implementation for Crypto Chart
     *
     * Following Clean Architecture principles:
     * - Utils: Pure utility functions
     * - Domain: Business logic and data processing
     * - UI: Presentation and user interaction
     * - Services: External communication
     * - Controller: Orchestration
     */

    // ===================================================
    // TYPES - TypeScript-style type definitions
    // ===================================================
    /**
     * @typedef {Object} PriceDataPoint
     * @property {string} timestamp - ISO timestamp string
     * @property {number} price - Price value
     */

    /**
     * @typedef {Object} ExtremaPoint
     * @property {string} timestamp - ISO timestamp string
     * @property {number} price - Price value
     * @property {('top'|'bottom')} type - Type of extrema point
     * @property {number} [significance] - Calculated significance value
     */

    /**
     * @typedef {Object} ChartParams
     * @property {string} symbol - Trading pair symbol (e.g., "BTCUSDT")
     * @property {string} interval - Time interval (e.g., "1h", "4h")
     * @property {number} limit - Number of data points to fetch
     * @property {number} threshold - Precision threshold value
     */

    /**
     * @typedef {Object} ThresholdRange
     * @property {number} min - Minimum threshold value
     * @property {number} max - Maximum threshold value
     * @property {number} step - Step size for threshold slider
     */

    /**
     * @typedef {Object} ChartData
     * @property {PriceDataPoint[]} filteredData - Filtered data points
     * @property {ExtremaPoint[]} extremaPoints - Extrema points
     */

    /**
     * @typedef {Object} PriceRange
     * @property {number} topY - Top Y coordinate
     * @property {number} bottomY - Bottom Y coordinate
     * @property {number} topPrice - Top price value
     * @property {number} bottomPrice - Bottom price value
     * @property {number} height - Range height
     * @property {number} percentDiff - Percentage difference
     */

    /**
     * @typedef {Object} Dimensions
     * @property {number} width - Chart width in pixels
     * @property {number} height - Chart height in pixels
     * @property {Object} margin - Chart margins
     * @property {number} margin.top - Top margin
     * @property {number} margin.right - Right margin
     * @property {number} margin.bottom - Bottom margin
     * @property {number} margin.left - Left margin
     */

    // ===================================================
    // UTILITIES - Pure utility functions
    // ===================================================
    const ChartUtils = {
            /**
             * Format price for display based on magnitude
             * @param {number} price - The price to format
             * @param {number} [customDecimals] - Optional custom decimal places
             * @returns {string} Formatted price
             */
            formatPrice(price, customDecimals) {
                const magnitude = price > 0 ? Math.pow(10, Math.floor(Math.log10(price))) : 1;

                let decimals = customDecimals;
                if (decimals === undefined) {
                    decimals = 2;
                    if (magnitude < 1) decimals = 4;
                    else if (magnitude < 10) decimals = 3;
                    else if (magnitude < 100) decimals = 2;
                    else decimals = 0;
                }

                return `${price.toFixed(decimals)}`;
            },

            /**
             * Calculate the ideal threshold slider range based on price
             * @param {number} lastPrice - The latest price value
             * @returns {ThresholdRange} Range settings for threshold slider
             */
            calculateThresholdRange(lastPrice) {
                const magnitude = lastPrice > 0 ? Math.pow(10, Math.ceil(Math.log10(lastPrice))) : 10;
                return {
                    min: 0,
                    max: magnitude * 0.10,
                    step: magnitude * 0.0001
                };
            },

            /**
             * Format date for display
             * @param {Date} date - Date to format
             * @returns {string} Formatted date string
             */
            formatDate(date) {
                return d3.timeFormat("%d %b %H:%M")(date);
            },

            /**
             * Calculate percentage difference between two prices
             * @param {number} price1 - First price
             * @param {number} price2 - Second price
             * @returns {number} Percentage difference
             */
            calculatePercentDifference(price1, price2) {
                if (price2 === 0) return 0;
                return ((price1 - price2) / price2) * 100;
            },

            /**
             * Format percentage with +/- sign
             * @param {number} percent - Percentage value
             * @param {number} [decimals=2] - Number of decimal places
             * @returns {string} Formatted percentage
             */
            formatPercent(percent, decimals = 2) {
                return `${percent >= 0 ? '+' : ''}${percent.toFixed(decimals)}%`;
            }
        };

    // ===================================================
    // DOMAIN - Business logic and data processing
    // ===================================================
    /**
     * Data processing utility functions
     * @namespace DataProcessorUtils
     */
    const DataProcessorUtils = {
        /**
         * Apply precision filtering to data based on threshold
         * @param {PriceDataPoint[]} data - Array of price data points
         * @param {number} thresholdUSDT - Price change threshold
         * @returns {PriceDataPoint[]} Filtered data points
         */
        applyPrecisionFilter(data, thresholdUSDT) {
            if (thresholdUSDT <= 0 || data.length <= 1) return [...data]; // Return a copy

            const filteredData = [data[0]];
            let lastIncludedPoint = data[0];

            for (let i = 1; i < data.length; i++) {
                const currentPoint = data[i];
                const priceChange = Math.abs(currentPoint.price - lastIncludedPoint.price);

                if (priceChange >= thresholdUSDT || i === data.length - 1) {
                    filteredData.push(currentPoint);
                    lastIncludedPoint = currentPoint;
                }
            }

            return filteredData;
        },

        /**
         * Find local extrema points (tops and bottoms)
         * @param {PriceDataPoint[]} data - Array of price data points
         * @returns {ExtremaPoint[]} Array of local extrema points
         */
        findLocalExtrema(data) {
            if (data.length < 3) return [];

            /** @type {ExtremaPoint[]} */
            const extrema = [];

            // Process middle points
            for (let i = 1; i < data.length - 1; i++) {
                const prev = data[i - 1].price;
                const current = data[i].price;
                const next = data[i + 1].price;

                if (current > prev && current > next) {
                    extrema.push({timestamp: data[i].timestamp, price: current, type: 'top'});
                } else if (current < prev && current < next) {
                    extrema.push({timestamp: data[i].timestamp, price: current, type: 'bottom'});
                }
            }

            // Include first point if it's a local extrema
            if (data.length > 1) {
                const firstPoint = data[0];
                const secondPoint = data[1];
                const type = firstPoint.price < secondPoint.price ? 'bottom' : 'top';
                extrema.push({timestamp: firstPoint.timestamp, price: firstPoint.price, type});
            }

            return this.filterExtrema(extrema, data);
        },

        /**
         * Filter extrema points to avoid overcrowding
         * @param {ExtremaPoint[]} extrema - Array of extrema points
         * @param {PriceDataPoint[]} data - Array of price data points
         * @returns {ExtremaPoint[]} Filtered extrema points
         * @private
         */
        filterExtrema(extrema, data) {
            if (extrema.length <= 5) return [...extrema]; // Return a copy

            // Calculate price range for significance normalization
            const priceRange = d3.max(data, d => d.price) - d3.min(data, d => d.price);
            if (priceRange === 0) return [];

            // Calculate significance for each extrema point
            const extremaWithSignificance = extrema.map(point => {
                const oppositeType = point.type === 'top' ? 'bottom' : 'top';

                // Find nearest extrema of opposite type
                const oppositeExtrema = extrema
                    .filter(e => e.type === oppositeType)
                    .sort((a, b) => Math.abs(new Date(a.timestamp) - new Date(point.timestamp)) -
                        Math.abs(new Date(b.timestamp) - new Date(point.timestamp)));

                const significance = oppositeExtrema.length > 0
                    ? Math.abs(point.price - oppositeExtrema[0].price) / priceRange
                    : 0.2; // Default significance

                return {...point, significance};
            });

            // Return most significant points
            return extremaWithSignificance
                .sort((a, b) => b.significance - a.significance)
                .slice(0, Math.min(8, extremaWithSignificance.length));
        }
    };

    // ===================================================
    // MODEL - Data management
    // ===================================================
    /**
     * Model for chart data and parameters
     */
    class ChartModel {
        /**
         * Creates a chart data model
         */
        constructor() {
            /** @type {PriceDataPoint[]} Raw unfiltered data from API */
            this.rawData = [];

            /** @type {ChartParams} Chart parameters */
            this.params = {
                symbol: 'BTCUSDT',
                interval: '1h',
                limit: 100,
                threshold: 0
            };

            /** @type {ThresholdRange} Threshold slider configuration */
            this.thresholdRange = {
                min: 0,
                max: 1000,
                step: 1
            };
        }

        /**
         * Update model parameters
         * @param {Partial<ChartParams>} params - Parameters to update
         * @returns {ChartParams} Updated parameters
         */
        setParams(params) {
            this.params = {...this.params, ...params};
            return this.getParams();
        }

        /**
         * Get current parameters
         * @returns {ChartParams} Current chart parameters
         */
        getParams() {
            return {...this.params};
        }

        /**
         * Get threshold range values
         * @returns {ThresholdRange} Current threshold range settings
         */
        getThresholdRange() {
            return {...this.thresholdRange};
        }

        /**
         * Update threshold range
         * @param {Partial<ThresholdRange>} range - Range values to update
         * @returns {ThresholdRange} Updated threshold range
         */
        updateThresholdRange(range) {
            this.thresholdRange = {...this.thresholdRange, ...range};
            return this.getThresholdRange();
        }

        /**
         * Apply filtering to data based on threshold
         * @param {PriceDataPoint[]} data - Raw data to filter
         * @param {number} threshold - Threshold value
         * @returns {PriceDataPoint[]} Filtered data points
         */
        filterData(data, threshold) {
            return DataProcessorUtils.applyPrecisionFilter(data, threshold);
        }

        /**
         * Process data for chart display
         * @returns {ChartData} Processed data
         */
        processData() {
            const filteredData = this.filterData(this.rawData, this.params.threshold);
            const extremaPoints = DataProcessorUtils.findLocalExtrema(filteredData);

            return {filteredData, extremaPoints};
        }

        /**
         * Get the last price from data
         * @param {PriceDataPoint[]} data - Price data
         * @returns {number|null} Last price or null if data is empty
         */
        getLastPrice(data) {
            if (data.length === 0) return null;
            return data[data.length - 1].price;
        }

        /**
         * Fetch data from the API
         * @returns {Promise<ChartData>} Processed data
         * @throws {Error} If API request fails
         */
        async fetchData() {
            try {
                const {symbol, interval, limit} = this.params;
                this.rawData = await ApiService.fetchPriceData(symbol, interval, limit);
                return this.processData();
            } catch (error) {
                console.error('Error fetching data:', error);
                throw error;
            }
        }
    }

    // ===================================================
    // VIEW COMPONENTS - UI building blocks
    // ===================================================
    /**
     * Component for chart controls
     */
    class ControlsComponent {
        /**
         * Create controls component
         */
        constructor() {
            // Initialize control elements
            this.limitSlider = /** @type {HTMLInputElement} */ (document.getElementById('limit-slider'));
            this.limitValue = document.getElementById('limit-value');
            this.precisionSlider = /** @type {HTMLInputElement} */ (document.getElementById('precision-slider'));
            this.precisionValue = document.getElementById('precision-value');

            // Initial values
            this.currentValues = {
                symbol: 'BTCUSDT',
                interval: '1h',
                limit: 100,
                threshold: 0
            };

            // Callbacks
            this.callbacks = {};
        }

        /**
         * Setup event listeners
         * @param {object} callbacks - Event callbacks
         */
        setupEventListeners(callbacks) {
            this.callbacks = {...callbacks};

            // Precision slider
            this.precisionSlider.addEventListener('input', () => {
                const value = parseFloat(this.precisionSlider.value);
                this.precisionValue.textContent = ChartUtils.formatPrice(value);

                if (this.callbacks.onThresholdChange) {
                    this.callbacks.onThresholdChange(value);
                }
            });

            this.precisionSlider.addEventListener('change', () => {
                if (this.callbacks.onThresholdSet) {
                    this.callbacks.onThresholdSet(parseFloat(this.precisionSlider.value));
                }
            });

            // Limit slider
            this.limitSlider.addEventListener('input', () => {
                this.limitValue.textContent = this.limitSlider.value;
            });

            this.limitSlider.addEventListener('change', () => {
                if (this.callbacks.onLimitChange) {
                    this.callbacks.onLimitChange(parseInt(this.limitSlider.value, 10));
                }
            });

            // Symbol radio buttons
            document.querySelectorAll('input[name="symbol"]').forEach(radio => {
                radio.addEventListener('change', () => {
                    if (this.callbacks.onSymbolChange) {
                        this.callbacks.onSymbolChange(radio.value);
                    }
                });
            });

            // Interval radio buttons
            document.querySelectorAll('input[name="interval"]').forEach(radio => {
                radio.addEventListener('change', () => {
                    if (this.callbacks.onIntervalChange) {
                        this.callbacks.onIntervalChange(radio.value);
                    }
                });
            });
        }

        /**
         * Update control values based on params
         * @param {ChartParams} params - Chart parameters
         * @param {ThresholdRange} [thresholdRange] - Threshold range settings
         * @returns {Object} Current control values
         */
        updateControls(params, thresholdRange) {
            // Update radio buttons
            this._setRadioValue('symbol', params.symbol);
            this._setRadioValue('interval', params.interval);

            // Update sliders
            this.limitSlider.value = String(params.limit);
            this.limitValue.textContent = String(params.limit);

            // Update threshold slider properties if provided
            if (thresholdRange) {
                this.precisionSlider.min = String(thresholdRange.min);
                this.precisionSlider.max = String(thresholdRange.max);
                this.precisionSlider.step = String(thresholdRange.step);
            }

            // Update threshold value
            this.precisionSlider.value = String(params.threshold);
            this.precisionValue.textContent = ChartUtils.formatPrice(params.threshold);

            // Store current values
            this.currentValues = {...params};

            return {...this.currentValues};
        }

        /**
         * Set radio button value
         * @param {string} name - Radio group name
         * @param {string} value - Value to select
         * @private
         */
        _setRadioValue(name, value) {
            const radio = document.querySelector(`input[name="${name}"][value="${value}"]`);
            if (radio) {
                radio.checked = true;
            }
        }
    }

    // ===================================================
    // CHART RENDERER - D3 Rendering Logic - RESPONSIVE
    // ===================================================
    /**
     * Component for D3 chart rendering
     */
    class ChartRenderer {
        /**
         * Create a chart renderer
         * @param {HTMLElement} container - Chart container
         * @param {Dimensions} dimensions - Chart dimensions
         */
        constructor(container, dimensions) {
            this.container = container;
            this.dimensions = dimensions;

            /** @type {PriceDataPoint[]} Store last rendered data */
            this.lastData = [];

            /** @type {ExtremaPoint[]} Store last rendered extrema points */
            this.lastExtremaPoints = [];

            // Initialize D3 elements
            this._initializeChart();
        }

        /**
         * Initialize D3 chart components
         * @private
         */
        _initializeChart() {
            const {width, height, margin} = this.dimensions;

            // Create SVG container with viewBox for responsiveness
            this.svg = d3.select(this.container)
                .append('svg')
                .attr('width', '100%')
                .attr('height', height + margin.top + margin.bottom)
                .attr('viewBox', `0 0 ${width + margin.left + margin.right} ${height + margin.top + margin.bottom}`)
                .attr('preserveAspectRatio', 'xMidYMid meet')
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            // Create clipping path
            this.svg.append("defs")
                .append("clipPath")
                .attr("id", "chart-area-clip")
                .append("rect")
                .attr("width", width)
                .attr("height", height)
                .attr("x", 0)
                .attr("y", 0);

            // Create a group for chart content that will be clipped
            this.chartGroup = this.svg.append('g')
                .attr('clip-path', 'url(#chart-area-clip)');

            // Create scales
            this.x = d3.scaleTime().range([0, width]);
            this.y = d3.scaleLinear().range([height, 0]);

            // Create generators
            this.lineGenerator = d3.line()
                .x(d => this.x(new Date(d.timestamp)))
                .y(d => this.y(d.price))
                .curve(d3.curveStepAfter);

            this.areaGenerator = d3.area()
                .x(d => this.x(new Date(d.timestamp)))
                .y0(height)
                .y1(d => this.y(d.price))
                .curve(d3.curveStepAfter);

            // Create axes
            this.xAxis = this.svg.append('g')
                .attr('class', 'x axis')
                .attr('transform', `translate(0,${height})`);

            this.yAxis = this.svg.append('g')
                .attr('class', 'y axis');

            // Create grid lines
            this.xGrid = this.chartGroup.append('g')
                .attr('class', 'grid x-grid');

            this.yGrid = this.chartGroup.append('g')
                .attr('class', 'grid y-grid');

            // Add labels
            this.dateRangeLabel = this.svg.append('text')
                .attr('class', 'date-range-label')
                .attr('text-anchor', 'middle')
                .attr('transform', `translate(${width / 2},0)`)
                .style('font-size', '12px')
                .style('fill', '#888')
                .text('Loading date range...');

            // Add chart elements
            this.path = this.chartGroup.append('path').attr('class', 'line');
            this.areaPath = this.chartGroup.append('path').attr('class', 'area');
        }

        /**
         * Resize the chart and fully redraw all elements
         * @param {Dimensions} dimensions - New dimensions
         */
        resize(dimensions) {
            // Update internal dimensions
            this.dimensions = dimensions;
            const {width, height, margin} = dimensions;

            // Update SVG container and viewBox
            const svgContainer = d3.select(this.container).select('svg');
            svgContainer
                .attr('width', '100%')
                .attr('height', height + margin.top + margin.bottom)
                .attr('viewBox', `0 0 ${width + margin.left + margin.right} ${height + margin.top + margin.bottom}`)
                .attr('preserveAspectRatio', 'xMidYMid meet');

            // Update clipPath
            this.svg.select("#chart-area-clip rect")
                .attr("width", width)
                .attr("height", height);

            // Update scales ranges
            this.x.range([0, width]);
            this.y.range([height, 0]);

            // Update axes positions
            this.xAxis.attr('transform', `translate(0,${height})`);

            // Update generators
            this.areaGenerator.y0(height);
            this.lineGenerator
                .x(d => this.x(new Date(d.timestamp)))
                .y(d => this.y(d.price));

            // Update labels
            this.dateRangeLabel.attr('transform', `translate(${width / 2},15)`);

            // Completely redraw the chart with stored data
            if (this.lastData && this.lastData.length > 0) {
                this.updateScales(this.lastData);
                this.updateAxes();
                this.updateChartLines(this.lastData);

                // Clear and redraw all extrema labels
                this.clearLabels();
                if (this.lastExtremaPoints && this.lastExtremaPoints.length > 0) {
                    this.renderExtremaPoints(this.lastExtremaPoints);
                }
            }
        }

        /**
         * Get D3 scales
         * @returns {{x: d3.ScaleTime, y: d3.ScaleLinear, margin: {top: number, right: number, bottom: number, left: number}}}
         *          D3 scales and margins
         */
        getScales() {
            return {
                x: this.x,
                y: this.y,
                margin: this.dimensions.margin
            };
        }

        /**
         * Update scales based on data
         * @param {PriceDataPoint[]} data - Chart data
         * @returns {{timeExtent: [Date, Date], priceExtent: [number, number]}} Scale extent information
         */
        updateScales(data) {
            // Store the data for potential resizing
            this.lastData = [...data];

            // Update date scale
            const timeExtent = d3.extent(data, d => new Date(d.timestamp));
            this.x.domain(timeExtent);

            // Update date range label
            const startDate = timeExtent[0];
            const endDate = timeExtent[1];
            const dateRangeText = `${ChartUtils.formatDate(startDate)} - ${ChartUtils.formatDate(endDate)}`;
            this.dateRangeLabel.text(dateRangeText);

            // Calculate price range with padding
            const minPrice = d3.min(data, d => d.price);
            const maxPrice = d3.max(data, d => d.price);
            const padding = (maxPrice - minPrice) * 0.05;
            this.y.domain([minPrice - padding, maxPrice + padding]);

            return {timeExtent, priceExtent: [minPrice, maxPrice]};
        }

        /**
         * Update axes with current scales, adapting to screen size
         */
        updateAxes() {
            const {width} = this.dimensions;

            // Calculate number of ticks based on width
            const xTickCount = this._calculateTickCount(width);
            const yTickCount = this._calculateTickCount(width, 0.6);

            // Update X axis with adaptive ticks
            this.xAxis.call(
                d3.axisBottom(this.x)
                    .ticks(xTickCount)
                    .tickFormat(d => {
                        // For small screens, simplify the date format
                        if (width < 500) {
                            return d3.timeFormat("%d/%m")(d);
                        }
                        return d3.timeFormat("%b %d %H:%M")(d);
                    })
            );

            // Update Y axis with adaptive ticks
            this.yAxis.call(
                d3.axisLeft(this.y)
                    .ticks(yTickCount)
                    .tickFormat(d => `${d.toLocaleString()}`)
            );

            // Update grid lines
            this.xGrid.call(
                d3.axisBottom(this.x)
                    .ticks(Math.max(5, xTickCount))
                    .tickSize(-this.dimensions.height)
                    .tickFormat('')
            );

            this.yGrid.call(
                d3.axisLeft(this.y)
                    .ticks(Math.max(5, yTickCount))
                    .tickSize(-this.dimensions.width)
                    .tickFormat('')
            );
        }

        /**
         * Calculate appropriate tick count based on width
         * @param {number} width - Chart width
         * @param {number} [factor=1] - Adjustment factor
         * @returns {number} - Appropriate tick count
         * @private
         */
        _calculateTickCount(width, factor = 1) {
            // Base calculation for ticks
            let tickCount = Math.floor(width / 100) * factor;

            // Ensure reasonable limits
            tickCount = Math.max(3, Math.min(10, tickCount));

            return tickCount;
        }

        /**
         * Clear existing chart labels
         */
        clearLabels() {
            this.svg.selectAll('.extrema-label').remove();
            this.svg.selectAll('.data-point').remove();
        }

        /**
         * Update chart lines and areas
         * @param {PriceDataPoint[]} data - Chart data
         */
        updateChartLines(data) {
            this.path.datum(data).attr('d', this.lineGenerator);
            this.areaPath.datum(data).attr('d', this.areaGenerator);
        }

        /**
         * Get the coordinates for a data point
         * @param {PriceDataPoint} dataPoint - The data point
         * @returns {{x: number, y: number, price: number}} Position information
         */
        getPointCoordinates(dataPoint) {
            const x = this.x(new Date(dataPoint.timestamp));
            const y = this.y(dataPoint.price);
            return {x, y, price: dataPoint.price};
        }

        /**
         * Render extrema points on chart
         * @param {ExtremaPoint[]} extremaPoints - Extrema points to render
         */
        renderExtremaPoints(extremaPoints) {
            // Store extrema points for redrawing on resize
            this.lastExtremaPoints = [...extremaPoints];

            // Get chart width to adapt label size
            const {width} = this.dimensions;
            const isSmallScreen = width < 600;

            // Adjust label size for small screens
            const labelWidth = isSmallScreen ? 44 : 60;
            const labelHeight = isSmallScreen ? 16 : 20;
            const fontSize = isSmallScreen ? '9px' : '11px';

            extremaPoints.forEach(point => {
                const pointX = this.x(new Date(point.timestamp));
                const pointY = this.y(point.price);
                const isTop = point.type === 'top';
                const color = isTop ? '#4caf50' : '#ff5252';

                // Background rectangle
                this.svg.append('rect')
                    .attr('class', 'extrema-label')
                    .attr('x', pointX - labelWidth / 2)
                    .attr('y', isTop ? pointY - labelHeight - 5 : pointY + 5)
                    .attr('width', labelWidth)
                    .attr('height', labelHeight)
                    .attr('rx', 3)
                    .attr('ry', 3)
                    .attr('fill', color)
                    .attr('opacity', 0.85);

                // Price text
                this.svg.append('text')
                    .attr('class', 'extrema-label')
                    .attr('x', pointX)
                    .attr('y', isTop ? pointY - labelHeight / 2 - 5 : pointY + labelHeight / 2 + 5)
                    .attr('text-anchor', 'middle')
                    .attr('fill', 'white')
                    .attr('font-size', fontSize)
                    .attr('font-weight', 'bold')
                    .attr('dominant-baseline', 'middle') // Center text vertically
                    .text(this._formatExtremaPrice(point.price, isSmallScreen));
            });
        }

        /**
         * Format price for extrema labels, adapting to screen size
         * @param {number} price - Price to format
         * @param {boolean} isSmallScreen - If true, use compact notation
         * @returns {string} Formatted price
         * @private
         */
        _formatExtremaPrice(price, isSmallScreen) {
            // Determine number of decimals based on price magnitude
            const magnitude = price > 0 ? Math.pow(10, Math.floor(Math.log10(price))) : 1;

            if (isSmallScreen && magnitude >= 1000) {
                return `${(price / 1000).toFixed(1)}K`;
            }

            if (magnitude >= 1000) {
                // For large numbers (BTC, ETH), show whole numbers
                return Math.round(price).toLocaleString();
            } else if (magnitude >= 100) {
                // For medium-large numbers, 0 decimals
                return price.toFixed(0);
            } else if (magnitude >= 10) {
                // For medium numbers, 1 decimal
                return price.toFixed(1);
            } else if (magnitude >= 1) {
                // For small numbers, 2 decimals
                return price.toFixed(2);
            } else if (magnitude >= 0.1) {
                // For very small numbers (like XRP), 3 decimals
                return price.toFixed(3);
            } else if (magnitude >= 0.01) {
                // For extremely small numbers, 4 decimals
                return price.toFixed(4);
            } else {
                // For tiny prices, 5 decimals
                return price.toFixed(5);
            }
        }
    }

    // ===================================================
    // VIEW - Chart visualization - RESPONSIVE
    // ===================================================
    /**
     * Main chart view
     */
    class ChartView {
        /**
         * Creates a chart view
         * @param {string} containerId - Chart container ID
         */
        constructor(containerId) {
            /** @type {HTMLElement} Main chart container */
            this.container = document.getElementById(containerId);

            /** @type {HTMLElement} Chart title element */
            this.chartTitle = document.getElementById('chart-title');

            /** @type {HTMLElement} Loading indicator */
            this.loadingEl = document.getElementById('loading');

            // Chart configuration
            /** @type {{top: number, right: number, bottom: number, left: number}} */
            this.margin = {top: 20, right: 80, bottom: 40, left: 80}; 

            // Calculate initial dimensions based on container
            this._calculateDimensions();

            // Set initial container height explicitly to match dimensions
            const totalHeight = this.height + this.margin.top + this.margin.bottom;
            this.container.style.height = `${totalHeight}px`;

            // Initialize chart renderer with plugin support
            this.renderer = new ChartRendererWithPlugins(this.container, {
                width: this.width,
                height: this.height,
                margin: this.margin
            });

            // Initialize controls component
            this.controls = new ControlsComponent();

            // Store current data
            /** @type {PriceDataPoint[]} */
            this.currentData = [];

            // Debounce resize handler to improve performance
            this._debouncedResize = this._debounce(this._handleResize.bind(this), 150);

            // Add resize event listener
            window.addEventListener('resize', this._debouncedResize);
        }

        /**
         * Debounce function to limit resize events
         * @param {Function} func - Function to debounce
         * @param {number} wait - Milliseconds to wait
         * @returns {Function} Debounced function
         * @private
         */
        _debounce(func, wait) {
            let timeout;
            return function () {
                const context = this;
                const args = arguments;
                clearTimeout(timeout);
                timeout = setTimeout(() => {
                    func.apply(context, args);
                }, wait);
            };
        }

        /**
         * Calculate dimensions based on container width
         * @private
         */
        _calculateDimensions() {
            // Get the actual container width
            const containerWidth = this.container.clientWidth;

            // Set margins based on screen size - more balanced approach
            if (containerWidth < 480) {
                // Mobile screens - modest margin reduction
                this.margin.left = 60;
                this.margin.right = 60;
                this.margin.top = 20;
                this.margin.bottom = 35;
            } else {
                // Desktop screens - standard margins
                this.margin.left = 80;
                this.margin.right = 80;
                this.margin.top = 20;
                this.margin.bottom = 40;
            }

            /** @type {number} Chart width */
            this.width = Math.max(300, containerWidth - this.margin.left - this.margin.right);

            /** @type {number} Chart height */
            // Adaptive aspect ratio based on screen size
            let aspectRatio = 0.5; // Standard aspect ratio for desktop
            
            if (containerWidth < 480) {
                // Slightly taller for mobile (not too extreme)
                aspectRatio = 0.55;
            }
            
            this.height = Math.round(this.width * aspectRatio);
            
            // Ensure minimum and maximum height
            this.height = Math.max(200, Math.min(500, this.height));
        }

        /**
         * Handle window resize events
         * @private
         */
        _handleResize() {
            // Recalculate dimensions
            this._calculateDimensions();

            // Update container height explicitly to match new dimensions
            const totalHeight = this.height + this.margin.top + this.margin.bottom;
            this.container.style.height = `${totalHeight}px`;

            // Resize the renderer
            this.renderer.resize({
                width: this.width,
                height: this.height,
                margin: this.margin
            });
            
            // Plugins are notified of resize in the ChartRendererWithPlugins resize method
        }

        /**
         * Set up event listeners
         * @param {object} callbacks - Callback functions for events
         */
        setupEventListeners(callbacks) {
            // Setup controls component listeners
            this.controls.setupEventListeners({
                onSymbolChange: callbacks.onSymbolChange,
                onIntervalChange: callbacks.onIntervalChange,
                onLimitChange: callbacks.onLimitChange,
                onThresholdChange: callbacks.onThresholdChange,
                onThresholdSet: callbacks.onThresholdSet,
                onRefresh: callbacks.onRefresh
            });

            // Handle back/forward navigation
            window.addEventListener('popstate', () => {
                if (callbacks.onPopState) {
                    callbacks.onPopState();
                }
            });
        }

        /**
         * Update chart title based on parameters
         * @param {ChartParams} params - Chart parameters
         * @returns {string} Updated title
         */
        updateChartTitle(params) {
            const symbolDisplay = params.symbol.replace('USDT', '');
            const title = `${symbolDisplay} on ${params.interval}`;
            this.chartTitle.textContent = title;
            return title;
        }

        /**
         * Update UI controls based on parameters
         * @param {ChartParams} params - Chart parameters
         * @param {ThresholdRange} [thresholdRange] - Optional threshold range settings
         * @returns {Object} Current control values
         */
        updateControls(params, thresholdRange) {
            return this.controls.updateControls(params, thresholdRange);
        }

        /**
         * Show loading indicator
         * @param {string} [message] - Optional loading message
         */
        showLoading(message = 'Loading data...') {
            this.loadingEl.style.display = 'block';
            this.loadingEl.textContent = message;
        }

        /**
         * Hide loading indicator
         */
        hideLoading() {
            this.loadingEl.style.display = 'none';
        }

        /**
         * Show error message
         * @param {string} [message] - Error message
         */
        showError(message) {
            this.loadingEl.style.display = 'block';
            this.loadingEl.textContent = message || 'Error loading data. Please try again.';
        }

        /**
         * Render the chart with data
         * @param {PriceDataPoint[]} data - Price data points to render
         * @param {ExtremaPoint[]} [extremaPoints] - Optional extrema points to highlight
         * @returns {Object} Rendering results
         */
        renderChart(data, extremaPoints) {
            if (data.length === 0) return {success: false, reason: 'No data'};

            // Store current data for hover percentage calculations
            this.currentData = [...data];

            // Update scales
            const scaleInfo = this.renderer.updateScales(data);

            // Update axes
            this.renderer.updateAxes();

            // Update line and area paths
            this.renderer.updateChartLines(data);

            // Clear existing extrema labels
            this.renderer.clearLabels();

            // Get the last data point
            const lastPoint = data[data.length - 1];
            
            // Add extrema points
            if (extremaPoints && extremaPoints.length > 0) {
                this.renderer.renderExtremaPoints(extremaPoints);
            }

            return {
                success: true,
                dataPoints: data.length,
                extremaPoints: extremaPoints ? extremaPoints.length : 0,
                scaleInfo,
                currentPrice: lastPoint.price
            };
        }
    }

    // ===================================================
    // Controller - App orchestration
    // ===================================================
    /**
     * Modern chart controller using composition
     */
    class ChartController {
        /**
         * Creates a chart controller
         */
        constructor() {
            /** @type {ChartParams} Default settings */
            this.defaults = {
                symbol: 'BTCUSDT',
                interval: '1h',
                limit: 100,
                threshold: 0
            };

            /** @type {ChartModel} Data model */
            this.model = new ChartModel();

            /** @type {ChartView} UI view */
            this.view = new ChartView('chart-container');
            
            // Features/components initialized via composition
            this.initPlugins();
            this.initContextMenu();

            // Load initial state from URL
            this.loadFromUrl();

            // Setup event listeners
            this.setupEventListeners();

            // Initial chart render
            this.updateChart(true);
        }

        /**
         * Initialize plugin system
         */
        initPlugins() {
            // Create a plugin manager and attach to renderer
            const renderer = this.view.renderer;
            const container = this.view.container;
            
            // Create the plugin manager
            renderer.pluginManager = new ChartPluginManager(
                renderer, container
            );
            
            // Add plugins
            renderer.pluginManager.add(new CurrentPricePlugin());
            renderer.pluginManager.add(new PriceRangePlugin());
            renderer.pluginManager.add(new PriceGuidePlugin());
            renderer.pluginManager.add(new MiddleLinePlugin());
        }
        
        /**
         * Initialize context menu
         */
        initContextMenu() {
            this.contextMenu = new ContextMenuManager('chart-container', this);
        }

        /**
         * Load settings from URL parameters
         * @returns {Object} Loaded parameters
         */
        loadFromUrl() {
            const {params, thresholdRange} = URLHandler.loadFromUrl(this.defaults);

            // Update model
            this.model.setParams(params);

            // Update threshold range if provided
            if (Object.keys(thresholdRange).length > 0) {
                this.model.updateThresholdRange(thresholdRange);
            }

            // Update view
            this.view.updateChartTitle(params);
            this.view.updateControls(params, this.model.getThresholdRange());

            return {params, thresholdRange};
        }

        /**
         * Set up event listeners
         */
        setupEventListeners() {
            this.view.setupEventListeners({
                onSymbolChange: this.handleSymbolChange.bind(this),
                onIntervalChange: (interval) => this.handleParamChange('interval', interval),
                onLimitChange: (limit) => this.handleParamChange('limit', parseInt(limit, 10)),
                onThresholdChange: this.handleThresholdChange.bind(this),
                onThresholdSet: this.handleThresholdSet.bind(this),
                onRefresh: this.handleRefresh.bind(this),
                onPopState: this.handlePopState.bind(this)
            });
        }

        /**
         * Handle symbol change (special case because we reset threshold)
         * @param {string} symbol - New symbol value
         */
        handleSymbolChange(symbol) {
            const currentParams = this.model.getParams();
            if (currentParams.symbol === symbol) return;

            // Update model with new symbol and reset threshold
            const updatedParams = this.model.setParams({
                symbol,
                threshold: 0
            });

            // Update URL
            URLHandler.updateUrl(updatedParams, this.model.getThresholdRange());

            // Refresh chart
            this.updateChart(true);
        }

        /**
         * Generic handler for parameter changes
         * @param {string} paramName - Name of parameter to change
         * @param {any} value - New value
         */
        handleParamChange(paramName, value) {
            // Create update object with parameter name as key
            const update = { [paramName]: value };
            
            // Update model
            const updatedParams = this.model.setParams(update);
            
            // Update URL
            URLHandler.updateUrl(updatedParams, this.model.getThresholdRange());
            
            // Refresh chart
            this.updateChart(true);
        }

        /**
         * Handle threshold slider change (live update)
         * @param {number} threshold - New threshold value
         */
        handleThresholdChange(threshold) {
            this.model.setParams({threshold});

            // Only update chart, don't update URL yet (wait for mouse release)
            if (this.model.rawData.length > 0) {
                const {filteredData, extremaPoints} = this.model.processData();
                this.view.renderChart(filteredData, extremaPoints);
            }
        }

        /**
         * Handle threshold slider set (after mouse release)
         * @param {number} threshold - Final threshold value
         */
        handleThresholdSet(threshold) {
            const updatedParams = this.model.setParams({threshold});
            URLHandler.updateUrl(updatedParams, this.model.getThresholdRange());
        }

        /**
         * Handle refresh button click
         */
        handleRefresh() {
            this.updateChart(true);
        }

        /**
         * Handle browser back/forward navigation
         */
        handlePopState() {
            this.loadFromUrl();
            this.updateChart(true);
        }

        /**
         * Calculate and update threshold slider based on price data
         * @param {PriceDataPoint[]} data - Price data points
         * @returns {ThresholdRange|null} New threshold range or null if data is empty
         */
        calculateThresholdRange(data) {
            if (data.length === 0) return null;

            const lastPrice = data[data.length - 1].price;
            const range = ChartUtils.calculateThresholdRange(lastPrice);

            return range;
        }

        /**
         * Fetch data and update chart
         * @param {boolean} [forceRefresh=false] - Force data refresh from API
         * @returns {Promise<Object>} Update results
         */
        async updateChart(forceRefresh = false) {
            // Update chart title
            const params = this.model.getParams();
            this.view.updateChartTitle(params);

            try {
                let chartData;

                // Show loading indicator for new data
                if (this.model.rawData.length === 0 || forceRefresh) {
                    this.view.showLoading();
                    chartData = await this.model.fetchData();
                } else {
                    // Use existing data
                    chartData = this.model.processData();
                }

                const {filteredData, extremaPoints} = chartData;

                // Update threshold slider based on data for new data
                if (forceRefresh && filteredData.length > 0) {
                    const newRange = this.calculateThresholdRange(filteredData);
                    if (newRange) {
                        this.model.updateThresholdRange(newRange);
                        this.view.updateControls(params, newRange);
                    }
                }

                // Hide loading and render chart
                this.view.hideLoading();
                const renderResult = this.view.renderChart(filteredData, extremaPoints);
                
                // Notify plugins after update
                if (this.view.renderer.pluginManager) {
                    this.view.renderer.pluginManager.onUpdate();
                }

                return {
                    success: true,
                    renderResult,
                    dataPoints: filteredData.length
                };
            } catch (error) {
                console.error('Error updating chart:', error);

                // Provide specific error messages based on error type
                let errorMessage = 'Error loading data. Please try again.';
                if (error.message.includes('API error')) {
                    errorMessage = 'Server error. Please try again later.';
                } else if (error.message.includes('network')) {
                    errorMessage = 'Network error. Please check your connection.';
                }

                this.view.showError(errorMessage);

                return {
                    success: false,
                    error: errorMessage,
                    originalError: error.message
                };
            }
        }
    }

    // Use composition instead of inheritance for plugin support
    class ChartRendererWithPlugins {
        /**
         * Create a chart renderer with plugin support
         * @param {HTMLElement} container - Chart container
         * @param {Dimensions} dimensions - Chart dimensions
         */
        constructor(container, dimensions) {
            // Create the base renderer
            this.renderer = new ChartRenderer(container, dimensions);
            
            // Plugin manager
            this.pluginManager = null;
            
            // Forward properties from the base renderer
            this.container = this.renderer.container;
            this.dimensions = this.renderer.dimensions;
            this.svg = this.renderer.svg;
            this.chartGroup = this.renderer.chartGroup;
            this.x = this.renderer.x;
            this.y = this.renderer.y;
            this.lastData = this.renderer.lastData;
            this.lastExtremaPoints = this.renderer.lastExtremaPoints;
        }
        
        /**
         * Proxy method calls to the base renderer with plugin support
         * @param {string} methodName - Method to call
         * @param {...any} args - Arguments to pass
         * @returns {any} Result from the method
         * @private
         */
        _proxyMethod(methodName, ...args) {
            if (typeof this.renderer[methodName] !== 'function') {
                throw new Error(`Method ${methodName} not found on ChartRenderer`);
            }
            
            return this.renderer[methodName](...args);
        }
        
        /**
         * Resize the chart with plugin support
         * @param {Dimensions} dimensions - New dimensions
         */
        resize(dimensions) {
            this._proxyMethod('resize', dimensions);
            
            // Update local references - important to keep these in sync
            this.dimensions = this.renderer.dimensions;
            this.x = this.renderer.x;
            this.y = this.renderer.y;
            
            // Notify plugins
            if (this.pluginManager) {
                this.pluginManager.onResize();
            }
        }
        
        // Proxy all other methods to the base renderer
        getScales() {
            return this._proxyMethod('getScales');
        }
        
        updateScales(data) {
            const result = this._proxyMethod('updateScales', data);
            this.lastData = this.renderer.lastData;
            return result;
        }
        
        updateAxes() {
            return this._proxyMethod('updateAxes');
        }
        
        clearLabels() {
            return this._proxyMethod('clearLabels');
        }
        
        updateChartLines(data) {
            return this._proxyMethod('updateChartLines', data);
        }
        
        getPointCoordinates(dataPoint) {
            return this._proxyMethod('getPointCoordinates', dataPoint);
        }
        
        renderExtremaPoints(extremaPoints) {
            const result = this._proxyMethod('renderExtremaPoints', extremaPoints);
            this.lastExtremaPoints = this.renderer.lastExtremaPoints;
            return result;
        }
    }
    
    // Add Context Menu functionality
    class ContextMenuManager {
        constructor(chartContainer, controller) {
            this.chartContainer = document.getElementById(chartContainer);
            this.contextMenu = document.getElementById('chart-context-menu');
            this.controller = controller;
            this.longPressTimer = null;
            this.longPressDelay = 700; // 700ms delay for long press detection
            
            // Initialize
            this.setupEventListeners();
        }
        
        setupEventListeners() {
            // Prevent default context menu on chart container
            this.chartContainer.addEventListener('contextmenu', (event) => {
                event.preventDefault();
                // Pass the event directly to get exact cursor position
                this.showContextMenu(event);
            });
            
            // Hide menu when clicking elsewhere
            document.addEventListener('click', () => {
                this.hideContextMenu();
            });
            
            // Handle menu item clicks
            this.contextMenu.querySelectorAll('.context-menu-item').forEach(item => {
                item.addEventListener('click', () => {
                    this.controller.handleRefresh();
                });
            });
            
            // Add touch events support
            this.chartContainer.addEventListener('touchstart', this.handleTouchStart.bind(this), { passive: true });
            this.chartContainer.addEventListener('touchmove', this.handleTouchMove.bind(this), { passive: true });
            this.chartContainer.addEventListener('touchend', this.handleTouchEnd.bind(this), { passive: true });
        }
        
        handleTouchStart(event) {
            if (event.touches.length === 1) {
                // Start timer for long press
                this.longPressTimer = setTimeout(() => {
                    const touch = event.touches[0];
                    // Convert touch to event-like object with clientX/Y
                    this.showContextMenu({
                        clientX: touch.clientX,
                        clientY: touch.clientY,
                        preventDefault: () => {}
                    });
                }, this.longPressDelay);
            }
        }
        
        handleTouchMove() {
            // Cancel long press on movement
            if (this.longPressTimer) {
                clearTimeout(this.longPressTimer);
                this.longPressTimer = null;
            }
        }
        
        handleTouchEnd() {
            // Cancel long press on touch end
            if (this.longPressTimer) {
                clearTimeout(this.longPressTimer);
                this.longPressTimer = null;
            }
        }
        
        showContextMenu(event) {
            // First display the menu so we can get its dimensions
            this.contextMenu.style.display = 'block';
            this.contextMenu.style.left = '-9999px'; // Position offscreen initially
            
            // Get menu dimensions after it's visible
            const menuWidth = this.contextMenu.offsetWidth;
            const menuHeight = this.contextMenu.offsetHeight;
            
            // Get cursor position relative to viewport
            const x = event.clientX;
            const y = event.clientY;
            
            // Set position directly at the cursor position
            let left = x;
            let top = y;
            
            // Adjust if too close to right edge
            if (left + menuWidth > window.innerWidth - 5) {
                left = left - menuWidth;
            }
            
            // Adjust if too close to bottom edge
            if (top + menuHeight > window.innerHeight - 5) {
                top = top - menuHeight;
            }
            
            // Set final position (using fixed positioning)
            this.contextMenu.style.position = 'fixed';
            this.contextMenu.style.left = `${left}px`;
            this.contextMenu.style.top = `${top}px`;
        }
        
        hideContextMenu() {
            this.contextMenu.style.display = 'none';
        }
    }
    
    // Initialize the chart application with plugins and context menu
    document.addEventListener('DOMContentLoaded', () => {
        // Create the main chart controller that uses composition for features
        window.cryptoChart = new ChartController();
    });
</script>
</body>
</html>