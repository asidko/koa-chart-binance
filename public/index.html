<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crypto Price Chart</title>
    <link rel="icon" href="favicon.ico" type="image/x-icon">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .controls {
            margin: 20px 0;
            padding: 15px;
            background-color: #f9f9f9;
            border-radius: 6px;
            border: 1px solid #eee;
        }

        /* Two-column layout for controls */
        .control-row {
            display: flex;
            gap: 20px;
            margin-bottom: 15px;
        }

        .control-group {
            flex: 1;
            padding-bottom: 15px;
        }

        .control-header {
            margin-bottom: 12px;
            display: flex;
            align-items: center;
        }

        .control-header label {
            font-weight: bold;
            margin: 0;
        }

        /* Radio group alignment */
        .radio-group {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: center;
        }

        .radio-option {
            display: flex;
            align-items: center;
        }

        .radio-option input {
            margin-right: 5px;
        }

        /* Slider container alignment */
        .slider-container {
            display: flex;
            align-items: center;
        }

        .slider-container label {
            min-width: 80px;
            font-weight: bold;
            margin-right: 10px;
        }

        .slider {
            flex-grow: 1;
            margin-right: 15px;
        }

        .slider-value {
            min-width: 60px;
            text-align: left;
            font-weight: bold;
        }

        /* Rest of styles remain the same */
        select {
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #ccc;
            font-size: 14px;
        }

        .description {
            margin-top: 5px;
            font-size: 12px;
            color: #666;
        }

        h1 {
            text-align: center;
            color: #333;
        }

        .chart-container {
            width: 100%;
            height: 500px;
            position: relative;
        }

        .line { fill: none; stroke: #ff9900; stroke-width: 2; }
        .area { fill: rgba(255, 153, 0, 0.1); }
        .axis { font-size: 12px; }

        .axis path, .axis line {
            fill: none;
            stroke: #ccc;
            shape-rendering: crispEdges;
        }

        .grid line {
            fill: none;
            stroke: #e0e0e0;
            shape-rendering: crispEdges;
        }

        .grid path { stroke-width: 0; }

        .refresh-btn {
            display: block;
            margin: 20px auto;
            padding: 8px 16px;
            background-color: #ff9900;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        .refresh-btn:hover { background-color: #e68a00; }
        .loading { text-align: center; color: #888; margin: 20px 0; font-style: italic; }

        /* Price guide styles */
        .price-guide {
            position: absolute;
            pointer-events: none;
            left: 70px;
            right: 50px;
            opacity: 0;
            transition: opacity 0.1s;
        }

        .price-guide-line {
            position: absolute;
            height: 0;
            width: 100%;
            border-top: 1px dashed #555;
        }

        .price-guide-label {
            position: absolute;
            right: -45px;
            transform: translateY(-50%);
            background-color: #555;
            color: white;
            font-size: 12px;
            padding: 3px 8px;
            border-radius: 3px;
        }

        .current-price-label {
            position: absolute;
            background-color: #3498db;
            color: white;
            font-size: 12px;
            padding: 3px 8px;
            border-radius: 3px;
            pointer-events: none;
            font-weight: bold;
            text-align: center;
            right: 5px;
        }

        /* Price percentage label */
        .price-guide-percent {
            position: absolute;
            right: -45px;
            transform: translateY(-50%);
            background-color: #555;
            color: white;
            font-size: 11px;
            padding: 2px 6px;
            border-radius: 3px;
            top: 20px; /* Position below the main price label */
        }

        /* Price range selection */
        .price-range-zone {
            position: absolute;
            background-color: rgba(52, 152, 219, 0.15);
            left: 70px;
            right: 50px;
            pointer-events: none;
            border-top: 1px dashed #3498db;
            border-bottom: 1px dashed #3498db;
        }

        .price-range-label {
            position: absolute;
            right: -45px;
            transform: translateY(-50%);
            background-color: #3498db;
            color: white;
            font-size: 12px;
            padding: 3px 8px;
            border-radius: 3px;
        }
    </style>
</head>
<body>
<div class="container">
    <h1 id="chart-title">BTC/USDT 1h Price Chart</h1>
    <div id="loading" class="loading">Loading data...</div>

    <div class="controls">
        <!-- First row: Coins and Interval side by side -->
        <div class="control-row">
            <!-- Symbol Selection -->
            <div class="control-group">
                <div class="control-header">
                    <label>Coins:</label>
                </div>
                <div class="radio-group">
                    <div class="radio-option">
                        <input type="radio" id="symbol-btcusdt" name="symbol" value="BTCUSDT" checked>
                        <label for="symbol-btcusdt">BTC</label>
                    </div>
                    <div class="radio-option">
                        <input type="radio" id="symbol-ethusdt" name="symbol" value="ETHUSDT">
                        <label for="symbol-ethusdt">ETH</label>
                    </div>
                    <div class="radio-option">
                        <input type="radio" id="symbol-xrpusdt" name="symbol" value="XRPUSDT">
                        <label for="symbol-xrpusdt">XRP</label>
                    </div>
                    <div class="radio-option">
                        <input type="radio" id="symbol-solusdt" name="symbol" value="SOLUSDT">
                        <label for="symbol-solusdt">SOL</label>
                    </div>
                    <div class="radio-option">
                        <input type="radio" id="symbol-bnbusdt" name="symbol" value="BNBUSDT">
                        <label for="symbol-bnbusdt">BNB</label>
                    </div>
                    <div class="radio-option">
                        <input type="radio" id="symbol-tonusdt" name="symbol" value="TONUSDT">
                        <label for="symbol-tonusdt">TON</label>
                    </div>
                </div>
            </div>

            <!-- Interval Selection -->
            <div class="control-group">
                <div class="control-header">
                    <label>Interval:</label>
                </div>
                <div class="radio-group">
                    <div class="radio-option">
                        <input type="radio" id="interval-1h" name="interval" value="1h" checked>
                        <label for="interval-1h">1h</label>
                    </div>
                    <div class="radio-option">
                        <input type="radio" id="interval-2h" name="interval" value="2h">
                        <label for="interval-2h">2h</label>
                    </div>
                    <div class="radio-option">
                        <input type="radio" id="interval-4h" name="interval" value="4h">
                        <label for="interval-4h">4h</label>
                    </div>
                    <div class="radio-option">
                        <input type="radio" id="interval-1d" name="interval" value="1d">
                        <label for="interval-1d">1d</label>
                    </div>
                    <div class="radio-option">
                        <input type="radio" id="interval-3d" name="interval" value="3d">
                        <label for="interval-3d">3d</label>
                    </div>
                </div>
            </div>
        </div>

        <!-- Second row: Limit and Threshold sliders side by side -->
        <div class="control-row">
            <!-- Data Limit Slider -->
            <div class="control-group">
                <div class="slider-container">
                    <label for="limit-slider">Limit:</label>
                    <input type="range" id="limit-slider" class="slider" min="10" max="500" step="10" value="100">
                    <span id="limit-value" class="slider-value">100</span>
                </div>
            </div>

            <!-- Threshold Slider -->
            <div class="control-group">
                <div class="slider-container">
                    <label for="precision-slider">Smooth:</label>
                    <input type="range" id="precision-slider" class="slider" min="0" max="1000" step="1" value="0">
                    <span id="precision-value" class="slider-value">$0</span>
                </div>
            </div>
        </div>
    </div>

    <div id="chart-container" class="chart-container">
        <!-- Price guide element (absolute positioned) -->
        <div id="price-guide" class="price-guide">
            <div class="price-guide-line"></div>
            <div class="price-guide-label"></div>
            <div class="price-guide-percent"></div>
        </div>
        <!-- Current price label (matches hover guide style) -->
        <div id="current-price-label" class="current-price-label"></div>
        <!-- Price range selection elements will be added here in JS -->
    </div>
    <button id="refresh" class="refresh-btn">Refresh Data</button>
</div>

<script type="module">
    /**
     * Clean Architecture Implementation for Crypto Chart
     *
     * Following Clean Architecture principles:
     * - Utils: Pure utility functions
     * - Domain: Business logic and data processing
     * - UI: Presentation and user interaction
     * - Services: External communication
     * - Controller: Orchestration
     */

    /**
     * @typedef {Object} PriceDataPoint
     * @property {string} timestamp - ISO timestamp string
     * @property {number} price - Price value
     */

    /**
     * @typedef {Object} ExtremaPoint
     * @property {string} timestamp - ISO timestamp string
     * @property {number} price - Price value
     * @property {('top'|'bottom')} type - Type of extrema point
     * @property {number} [significance] - Calculated significance value
     */

    /**
     * @typedef {Object} ChartParams
     * @property {string} symbol - Trading pair symbol (e.g., "BTCUSDT")
     * @property {string} interval - Time interval (e.g., "1h", "4h")
     * @property {number} limit - Number of data points to fetch
     * @property {number} threshold - Precision threshold value
     */

    /**
     * @typedef {Object} ThresholdRange
     * @property {number} min - Minimum threshold value
     * @property {number} max - Maximum threshold value
     * @property {number} step - Step size for threshold slider
     */

    /**
     * @typedef {Object} ChartData
     * @property {PriceDataPoint[]} filteredData - Filtered data points
     * @property {ExtremaPoint[]} extremaPoints - Extrema points
     */

    /**
     * @typedef {Object} PriceRange
     * @property {number} topY - Top Y coordinate
     * @property {number} bottomY - Bottom Y coordinate
     * @property {number} topPrice - Top price value
     * @property {number} bottomPrice - Bottom price value
     * @property {number} height - Range height
     * @property {number} percentDiff - Percentage difference
     */

        // ===================================================
        // UTILITIES - Pure utility functions
        // ===================================================
    const ChartUtils = {
            /**
             * Format price for display based on magnitude
             * @param {number} price - The price to format
             * @param {number} [customDecimals] - Optional custom decimal places
             * @returns {string} Formatted price
             */
            formatPrice(price, customDecimals) {
                const magnitude = price > 0 ? Math.pow(10, Math.floor(Math.log10(price))) : 1;

                let decimals = customDecimals;
                if (decimals === undefined) {
                    decimals = 2;
                    if (magnitude < 1) decimals = 4;
                    else if (magnitude < 10) decimals = 3;
                    else if (magnitude < 100) decimals = 2;
                    else decimals = 0;
                }

                return `${price.toFixed(decimals)}`;
            },

            /**
             * Calculate the ideal threshold slider range based on price
             * @param {number} lastPrice - The latest price value
             * @returns {ThresholdRange} Range settings for threshold slider
             */
            calculateThresholdRange(lastPrice) {
                const magnitude = lastPrice > 0 ? Math.pow(10, Math.ceil(Math.log10(lastPrice))) : 10;
                return {
                    min: 0,
                    max: magnitude * 0.20,
                    step: magnitude * 0.001
                };
            },

            /**
             * Format date for display
             * @param {Date} date - Date to format
             * @returns {string} Formatted date string
             */
            formatDate(date) {
                return d3.timeFormat("%d %b %H:%M")(date);
            },

            /**
             * Calculate percentage difference between two prices
             * @param {number} price1 - First price
             * @param {number} price2 - Second price
             * @returns {number} Percentage difference
             */
            calculatePercentDifference(price1, price2) {
                if (price2 === 0) return 0;
                return ((price1 - price2) / price2) * 100;
            },

            /**
             * Format percentage with +/- sign
             * @param {number} percent - Percentage value
             * @param {number} [decimals=2] - Number of decimal places
             * @returns {string} Formatted percentage
             */
            formatPercent(percent, decimals = 2) {
                return `${percent >= 0 ? '+' : ''}${percent.toFixed(decimals)}%`;
            }
        };

    // ===================================================
    // DOMAIN - Business logic and data processing
    // ===================================================
    /**
     * Handles data processing and analysis
     */
    class DataProcessor {
        /**
         * Apply precision filtering to data based on threshold
         * @param {PriceDataPoint[]} data - Array of price data points
         * @param {number} thresholdUSDT - Price change threshold
         * @returns {PriceDataPoint[]} Filtered data points
         */
        static applyPrecisionFilter(data, thresholdUSDT) {
            if (thresholdUSDT <= 0 || data.length <= 1) return [...data]; // Return a copy

            const filteredData = [data[0]];
            let lastIncludedPoint = data[0];

            for (let i = 1; i < data.length; i++) {
                const currentPoint = data[i];
                const priceChange = Math.abs(currentPoint.price - lastIncludedPoint.price);

                if (priceChange >= thresholdUSDT || i === data.length - 1) {
                    filteredData.push(currentPoint);
                    lastIncludedPoint = currentPoint;
                }
            }

            return filteredData;
        }

        /**
         * Find local extrema points (tops and bottoms)
         * @param {PriceDataPoint[]} data - Array of price data points
         * @returns {ExtremaPoint[]} Array of local extrema points
         */
        static findLocalExtrema(data) {
            if (data.length < 3) return [];

            /** @type {ExtremaPoint[]} */
            const extrema = [];

            // Process middle points
            for (let i = 1; i < data.length - 1; i++) {
                const prev = data[i-1].price;
                const current = data[i].price;
                const next = data[i+1].price;

                if (current > prev && current > next) {
                    extrema.push({ timestamp: data[i].timestamp, price: current, type: 'top' });
                } else if (current < prev && current < next) {
                    extrema.push({ timestamp: data[i].timestamp, price: current, type: 'bottom' });
                }
            }

            // Include first point if it's a local extrema
            if (data.length > 1) {
                const firstPoint = data[0];
                const secondPoint = data[1];
                const type = firstPoint.price < secondPoint.price ? 'bottom' : 'top';
                extrema.push({ timestamp: firstPoint.timestamp, price: firstPoint.price, type });
            }

            return DataProcessor.filterExtrema(extrema, data);
        }

        /**
         * Filter extrema points to avoid overcrowding
         * @param {ExtremaPoint[]} extrema - Array of extrema points
         * @param {PriceDataPoint[]} data - Array of price data points
         * @returns {ExtremaPoint[]} Filtered extrema points
         * @private
         */
        static filterExtrema(extrema, data) {
            if (extrema.length <= 5) return [...extrema]; // Return a copy

            // Calculate price range for significance normalization
            const priceRange = d3.max(data, d => d.price) - d3.min(data, d => d.price);
            if (priceRange === 0) return [];

            // Calculate significance for each extrema point
            const extremaWithSignificance = extrema.map(point => {
                const oppositeType = point.type === 'top' ? 'bottom' : 'top';

                // Find nearest extrema of opposite type
                const oppositeExtrema = extrema
                    .filter(e => e.type === oppositeType)
                    .sort((a, b) => Math.abs(new Date(a.timestamp) - new Date(point.timestamp)) -
                        Math.abs(new Date(b.timestamp) - new Date(point.timestamp)));

                const significance = oppositeExtrema.length > 0
                    ? Math.abs(point.price - oppositeExtrema[0].price) / priceRange
                    : 0.2; // Default significance

                return { ...point, significance };
            });

            // Return most significant points
            return extremaWithSignificance
                .sort((a, b) => b.significance - a.significance)
                .slice(0, Math.min(8, extremaWithSignificance.length));
        }
    }

    // ===================================================
    // SERVICES - API communication
    // ===================================================
    /**
     * Service for fetching data from API
     */
    class ApiService {
        /**
         * Fetch price data from API
         * @param {string} symbol - Trading pair symbol
         * @param {string} interval - Time interval
         * @param {number} limit - Number of data points
         * @returns {Promise<PriceDataPoint[]>} Price data
         * @throws {Error} If API request fails
         */
        static async fetchPriceData(symbol, interval, limit) {
            const apiUrl = `/api/btc-price?symbol=${symbol}&interval=${interval}&limit=${limit}`;

            const response = await fetch(apiUrl);
            if (!response.ok) {
                throw new Error(`API error: ${response.status}`);
            }

            return await response.json();
        }
    }

    // ===================================================
    // MODEL - Data management
    // ===================================================
    /**
     * Model for chart data and parameters
     */
    class ChartModel {
        /**
         * Creates a chart data model
         */
        constructor() {
            /** @type {PriceDataPoint[]} Raw unfiltered data from API */
            this.rawData = [];

            /** @type {ChartParams} Chart parameters */
            this.params = {
                symbol: 'BTCUSDT',
                interval: '1h',
                limit: 100,
                threshold: 0
            };

            /** @type {ThresholdRange} Threshold slider configuration */
            this.thresholdRange = {
                min: 0,
                max: 1000,
                step: 1
            };
        }

        /**
         * Update model parameters
         * @param {Partial<ChartParams>} params - Parameters to update
         * @returns {ChartParams} Updated parameters
         */
        setParams(params) {
            this.params = { ...this.params, ...params };
            return this.getParams();
        }

        /**
         * Get current parameters
         * @returns {ChartParams} Current chart parameters
         */
        getParams() {
            return { ...this.params };
        }

        /**
         * Get threshold range values
         * @returns {ThresholdRange} Current threshold range settings
         */
        getThresholdRange() {
            return { ...this.thresholdRange };
        }

        /**
         * Update threshold range
         * @param {Partial<ThresholdRange>} range - Range values to update
         * @returns {ThresholdRange} Updated threshold range
         */
        updateThresholdRange(range) {
            this.thresholdRange = { ...this.thresholdRange, ...range };
            return this.getThresholdRange();
        }

        /**
         * Apply filtering to data based on threshold
         * @param {PriceDataPoint[]} data - Raw data to filter
         * @param {number} threshold - Threshold value
         * @returns {PriceDataPoint[]} Filtered data points
         */
        filterData(data, threshold) {
            return DataProcessor.applyPrecisionFilter(data, threshold);
        }

        /**
         * Process data for chart display
         * @returns {ChartData} Processed data
         */
        processData() {
            const filteredData = this.filterData(this.rawData, this.params.threshold);
            const extremaPoints = DataProcessor.findLocalExtrema(filteredData);

            return { filteredData, extremaPoints };
        }

        /**
         * Get the last price from data
         * @param {PriceDataPoint[]} data - Price data
         * @returns {number|null} Last price or null if data is empty
         */
        getLastPrice(data) {
            if (data.length === 0) return null;
            return data[data.length - 1].price;
        }

        /**
         * Fetch data from the API
         * @returns {Promise<ChartData>} Processed data
         * @throws {Error} If API request fails
         */
        async fetchData() {
            try {
                const { symbol, interval, limit } = this.params;
                this.rawData = await ApiService.fetchPriceData(symbol, interval, limit);
                return this.processData();
            } catch (error) {
                console.error('Error fetching data:', error);
                throw error;
            }
        }
    }

    // ===================================================
    // VIEW COMPONENTS - UI building blocks
    // ===================================================
    /**
     * Component for displaying price guide
     */
    class PriceGuideComponent {
        /**
         * Create a price guide component
         * @param {HTMLElement} container - Parent container
         * @param {object} chartInfo - Chart scales and margins
         */
        constructor(container, chartInfo) {
            this.container = container;
            this.chartInfo = chartInfo;

            // Initialize elements
            this.priceGuide = document.getElementById('price-guide');
            this.priceGuideLine = this.priceGuide.querySelector('.price-guide-line');
            this.priceGuideLabel = this.priceGuide.querySelector('.price-guide-label');
            this.priceGuidePercent = this.priceGuide.querySelector('.price-guide-percent');
        }

        /**
         * Update the price guide position and content
         * @param {number} y - Y position in pixels
         * @param {PriceDataPoint[]} currentData - Current chart data
         * @returns {Object} State of price guide
         */
        update(y, currentData) {
            const hoveredPrice = this._calculatePriceAtPosition(y);

            // Update DOM
            this.priceGuide.style.top = `${y}px`;
            this.priceGuide.style.opacity = '1';
            this.priceGuideLabel.textContent = ChartUtils.formatPrice(hoveredPrice);

            // Update percentage difference
            const lastPrice = currentData.length > 0 ? currentData[currentData.length - 1].price : null;
            if (lastPrice !== null) {
                const percentDiff = ChartUtils.calculatePercentDifference(hoveredPrice, lastPrice);
                const formattedPercent = ChartUtils.formatPercent(percentDiff);
                const color = percentDiff >= 0 ? '#4caf50' : '#ff5252';

                this.priceGuidePercent.textContent = formattedPercent;
                this.priceGuidePercent.style.backgroundColor = color;
            } else {
                this.priceGuidePercent.textContent = '';
            }

            return {
                y,
                hoveredPrice,
                lastPrice,
                visible: true
            };
        }

        /**
         * Hide the price guide
         * @returns {Object} State of price guide
         */
        hide() {
            this.priceGuide.style.opacity = '0';
            this.priceGuidePercent.textContent = '';

            return {
                visible: false
            };
        }

        /**
         * Calculate price at position
         * @param {number} y - Y position in pixels
         * @returns {number} Price at position
         * @private
         */
        _calculatePriceAtPosition(y) {
            const mouseYInScaleSpace = y - this.chartInfo.margin.top;
            return this.chartInfo.y.invert(mouseYInScaleSpace);
        }
    }

    /**
     * Component for price range selection
     */
    class PriceRangeComponent {
        /**
         * Create a price range selection component
         * @param {HTMLElement} container - Parent container
         * @param {object} chartInfo - Chart scales and margins
         */
        constructor(container, chartInfo) {
            this.container = container;
            this.chartInfo = chartInfo;

            // Create elements
            this.rangeZone = document.createElement('div');
            this.rangeZone.className = 'price-range-zone';
            this.rangeZone.style.display = 'none';
            container.appendChild(this.rangeZone);

            this.topLabel = document.createElement('div');
            this.topLabel.className = 'price-range-label';
            container.appendChild(this.topLabel);

            this.bottomLabel = document.createElement('div');
            this.bottomLabel.className = 'price-range-label';
            container.appendChild(this.bottomLabel);

            // Drag state
            this.dragState = {
                isDragging: false,
                startY: 0,
                endY: 0
            };
        }

        /**
         * Start dragging operation
         * @param {number} y - Starting Y position
         * @returns {Object} Drag state
         */
        startDrag(y) {
            this.dragState = {
                isDragging: true,
                startY: y,
                endY: y
            };

            return { ...this.dragState };
        }

        /**
         * Update dragging position
         * @param {number} y - Current Y position
         * @returns {PriceRange|null} Price range info or null if not dragging
         */
        updateDrag(y) {
            if (!this.dragState.isDragging) return null;

            this.dragState.endY = y;
            const priceRange = this._calculatePriceRange();
            this._updateDisplay(priceRange);

            return priceRange;
        }

        /**
         * End dragging operation
         * @returns {Object} Results of the drag operation
         */
        endDrag() {
            if (!this.dragState.isDragging) {
                return { isSignificantDrag: false, dragState: { ...this.dragState } };
            }

            const isSignificantDrag = Math.abs(this.dragState.endY - this.dragState.startY) >= 5;

            if (!isSignificantDrag) {
                this.clear();
            }

            const result = {
                isSignificantDrag,
                dragState: { ...this.dragState }
            };

            this.dragState.isDragging = false;

            return result;
        }

        /**
         * Calculate price range based on current drag state
         * @returns {PriceRange} Price range info
         * @private
         */
        _calculatePriceRange() {
            const topY = Math.min(this.dragState.startY, this.dragState.endY);
            const bottomY = Math.max(this.dragState.startY, this.dragState.endY);
            const height = bottomY - topY;

            // Calculate prices from Y positions
            const topYInScale = topY - this.chartInfo.margin.top;
            const bottomYInScale = bottomY - this.chartInfo.margin.top;
            const topPrice = this.chartInfo.y.invert(topYInScale);
            const bottomPrice = this.chartInfo.y.invert(bottomYInScale);

            // Calculate percentage difference
            const priceDiff = Math.abs(topPrice - bottomPrice);
            const percentDiff = (priceDiff / bottomPrice) * 100;

            return {
                topY,
                bottomY,
                topPrice,
                bottomPrice,
                height,
                percentDiff
            };
        }

        /**
         * Update the display based on price range
         * @param {PriceRange} priceRange - Price range info
         * @private
         */
        _updateDisplay(priceRange) {
            const { topY, bottomY, topPrice, bottomPrice, height, percentDiff } = priceRange;

            // Update zone
            this.rangeZone.style.display = 'block';
            this.rangeZone.style.top = `${topY}px`;
            this.rangeZone.style.height = `${height}px`;

            // Update labels
            this.topLabel.style.display = 'block';
            this.topLabel.style.top = `${topY}px`;
            this.topLabel.textContent = ChartUtils.formatPrice(topPrice);

            this.bottomLabel.style.display = 'block';
            this.bottomLabel.style.top = `${bottomY}px`;
            this.bottomLabel.textContent = ChartUtils.formatPrice(bottomPrice);

            // Add percentage info if enough space
            if (height > 30) {
                this.topLabel.textContent += ` (${percentDiff.toFixed(2)}%)`;
            }
        }

        /**
         * Clear the selection
         */
        clear() {
            this.rangeZone.style.display = 'none';
            this.topLabel.style.display = 'none';
            this.bottomLabel.style.display = 'none';
        }

        /**
         * Check if component is in dragging state
         * @returns {boolean} True if dragging
         */
        isDraggingActive() {
            return this.dragState.isDragging;
        }
    }

    /**
     * Component for chart controls
     */
    class ControlsComponent {
        /**
         * Create controls component
         */
        constructor() {
            // Initialize control elements
            this.limitSlider = /** @type {HTMLInputElement} */ (document.getElementById('limit-slider'));
            this.limitValue = document.getElementById('limit-value');
            this.precisionSlider = /** @type {HTMLInputElement} */ (document.getElementById('precision-slider'));
            this.precisionValue = document.getElementById('precision-value');
            this.refreshButton = /** @type {HTMLButtonElement} */ (document.getElementById('refresh'));

            // Initial values
            this.currentValues = {
                symbol: 'BTCUSDT',
                interval: '1h',
                limit: 100,
                threshold: 0
            };

            // Callbacks
            this.callbacks = {};
        }

        /**
         * Setup event listeners
         * @param {object} callbacks - Event callbacks
         */
        setupEventListeners(callbacks) {
            this.callbacks = { ...callbacks };

            // Precision slider
            this.precisionSlider.addEventListener('input', () => {
                const value = parseFloat(this.precisionSlider.value);
                this.precisionValue.textContent = ChartUtils.formatPrice(value);

                if (this.callbacks.onThresholdChange) {
                    this.callbacks.onThresholdChange(value);
                }
            });

            this.precisionSlider.addEventListener('change', () => {
                if (this.callbacks.onThresholdSet) {
                    this.callbacks.onThresholdSet(parseFloat(this.precisionSlider.value));
                }
            });

            // Limit slider
            this.limitSlider.addEventListener('input', () => {
                this.limitValue.textContent = this.limitSlider.value;
            });

            this.limitSlider.addEventListener('change', () => {
                if (this.callbacks.onLimitChange) {
                    this.callbacks.onLimitChange(parseInt(this.limitSlider.value, 10));
                }
            });

            // Symbol radio buttons
            document.querySelectorAll('input[name="symbol"]').forEach(radio => {
                radio.addEventListener('change', () => {
                    if (this.callbacks.onSymbolChange) {
                        this.callbacks.onSymbolChange(radio.value);
                    }
                });
            });

            // Interval radio buttons
            document.querySelectorAll('input[name="interval"]').forEach(radio => {
                radio.addEventListener('change', () => {
                    if (this.callbacks.onIntervalChange) {
                        this.callbacks.onIntervalChange(radio.value);
                    }
                });
            });

            // Refresh button
            this.refreshButton.addEventListener('click', () => {
                if (this.callbacks.onRefresh) {
                    this.callbacks.onRefresh();
                }
            });
        }

        /**
         * Update control values based on params
         * @param {ChartParams} params - Chart parameters
         * @param {ThresholdRange} [thresholdRange] - Threshold range settings
         * @returns {Object} Current control values
         */
        updateControls(params, thresholdRange) {
            // Update radio buttons
            this._setRadioValue('symbol', params.symbol);
            this._setRadioValue('interval', params.interval);

            // Update sliders
            this.limitSlider.value = String(params.limit);
            this.limitValue.textContent = String(params.limit);

            // Update threshold slider properties if provided
            if (thresholdRange) {
                this.precisionSlider.min = String(thresholdRange.min);
                this.precisionSlider.max = String(thresholdRange.max);
                this.precisionSlider.step = String(thresholdRange.step);
            }

            // Update threshold value
            this.precisionSlider.value = String(params.threshold);
            this.precisionValue.textContent = ChartUtils.formatPrice(params.threshold);

            // Store current values
            this.currentValues = { ...params };

            return { ...this.currentValues };
        }

        /**
         * Set radio button value
         * @param {string} name - Radio group name
         * @param {string} value - Value to select
         * @private
         */
        _setRadioValue(name, value) {
            const radio = document.querySelector(`input[name="${name}"][value="${value}"]`);
            if (radio) {
                radio.checked = true;
            }
        }
    }

    // ===================================================
    // CHART RENDERER - D3 Rendering Logic
    // ===================================================
    /**
     * Component for D3 chart rendering
     */
    class ChartRenderer {
        /**
         * Create a chart renderer
         * @param {HTMLElement} container - Chart container
         * @param {object} dimensions - Chart dimensions
         */
        constructor(container, dimensions) {
            this.container = container;
            this.dimensions = dimensions;

            // Initialize D3 elements
            this._initializeChart();
        }

        /**
         * Initialize D3 chart components
         * @private
         */
        _initializeChart() {
            const { width, height, margin } = this.dimensions;

            // Create SVG container
            this.svg = d3.select(this.container)
                .append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            // Create clipping path
            this.svg.append("defs")
                .append("clipPath")
                .attr("id", "chart-area-clip")
                .append("rect")
                .attr("width", width)
                .attr("height", height)
                .attr("x", 0)
                .attr("y", 0);

            // Create a group for chart content that will be clipped
            this.chartGroup = this.svg.append('g')
                .attr('clip-path', 'url(#chart-area-clip)');

            // Create scales
            this.x = d3.scaleTime().range([0, width]);
            this.y = d3.scaleLinear().range([height, 0]);

            // Create generators
            this.lineGenerator = d3.line()
                .x(d => this.x(new Date(d.timestamp)))
                .y(d => this.y(d.price))
                .curve(d3.curveStepAfter);

            this.areaGenerator = d3.area()
                .x(d => this.x(new Date(d.timestamp)))
                .y0(height)
                .y1(d => this.y(d.price))
                .curve(d3.curveStepAfter);

            // Create axes
            this.xAxis = this.svg.append('g')
                .attr('class', 'x axis')
                .attr('transform', `translate(0,${height})`);

            this.yAxis = this.svg.append('g')
                .attr('class', 'y axis');

            // Create grid lines
            this.xGrid = this.chartGroup.append('g')
                .attr('class', 'grid x-grid');

            this.yGrid = this.chartGroup.append('g')
                .attr('class', 'grid y-grid');

            // Add labels
            this.dateRangeLabel = this.svg.append('text')
                .attr('class', 'date-range-label')
                .attr('text-anchor', 'middle')
                .attr('transform', `translate(${width/2},-10)`)
                .style('font-size', '12px')
                .style('fill', '#666')
                .text('Loading date range...');

            // Add Y axis label
            this.svg.append('text')
                .attr('text-anchor', 'middle')
                .attr('transform', `rotate(-90) translate(${-height/2},${-margin.left + 15})`)
                .style('font-size', '14px')
                .text('Price (USDT)');

            // Add chart elements
            this.path = this.chartGroup.append('path').attr('class', 'line');
            this.areaPath = this.chartGroup.append('path').attr('class', 'area');

            // Add current price indicators
            this.currentPriceLine = this.chartGroup.append('line')
                .attr('stroke', '#3498db')
                .attr('stroke-width', 1)
                .attr('stroke-dasharray', '5,3');

            this.currentPriceBullet = this.chartGroup.append('circle')
                .attr('r', 6)
                .attr('fill', '#3498db')
                .attr('stroke', 'white')
                .attr('stroke-width', 1);
        }

        /**
         * Get D3 scales
         * @returns {Object} D3 scales
         */
        getScales() {
            return {
                x: this.x,
                y: this.y,
                margin: this.dimensions.margin
            };
        }

        /**
         * Update scales based on data
         * @param {PriceDataPoint[]} data - Chart data
         * @returns {Object} Scale extent information
         */
        updateScales(data) {
            // Update date scale
            const timeExtent = d3.extent(data, d => new Date(d.timestamp));
            this.x.domain(timeExtent);

            // Update date range label
            const startDate = timeExtent[0];
            const endDate = timeExtent[1];
            const dateRangeText = `${ChartUtils.formatDate(startDate)} - ${ChartUtils.formatDate(endDate)}`;
            this.dateRangeLabel.text(dateRangeText);

            // Calculate price range with padding
            const minPrice = d3.min(data, d => d.price);
            const maxPrice = d3.max(data, d => d.price);
            const padding = (maxPrice - minPrice) * 0.05;
            this.y.domain([minPrice - padding, maxPrice + padding]);

            return { timeExtent, priceExtent: [minPrice, maxPrice] };
        }

        /**
         * Update axes with current scales
         */
        updateAxes() {
            // Update X axis
            this.xAxis.call(d3.axisBottom(this.x)
                .ticks(6)
                .tickFormat(d3.timeFormat('%b %d %H:%M')));

            // Update Y axis
            this.yAxis.call(d3.axisLeft(this.y)
                .tickFormat(d => `${d.toLocaleString()}`));

            // Update grid lines
            this.xGrid.call(d3.axisBottom(this.x)
                .ticks(10)
                .tickSize(-this.dimensions.height)
                .tickFormat(''));

            this.yGrid.call(d3.axisLeft(this.y)
                .ticks(10)
                .tickSize(-this.dimensions.width)
                .tickFormat(''));
        }

        /**
         * Clear existing chart labels
         */
        clearLabels() {
            this.svg.selectAll('.extrema-label').remove();
            this.svg.selectAll('.data-point').remove();
        }

        /**
         * Update chart lines and areas
         * @param {PriceDataPoint[]} data - Chart data
         */
        updateChartLines(data) {
            this.path.datum(data).attr('d', this.lineGenerator);
            this.areaPath.datum(data).attr('d', this.areaGenerator);
        }

        /**
         * Update current price indicator
         * @param {PriceDataPoint} lastPoint - Last price data point
         * @returns {Object} Position information
         */
        updateCurrentPriceIndicator(lastPoint) {
            const lastX = this.x(new Date(lastPoint.timestamp));
            const lastY = this.y(lastPoint.price);

            // Update horizontal line at current price
            this.currentPriceLine
                .attr('x1', 0)
                .attr('x2', this.dimensions.width)
                .attr('y1', lastY)
                .attr('y2', lastY);

            // Update bullet point
            this.currentPriceBullet
                .attr('cx', lastX)
                .attr('cy', lastY);

            // Ensure price indicators are drawn on top
            this.svg.node().appendChild(this.currentPriceLine.node());
            this.svg.node().appendChild(this.currentPriceBullet.node());

            return { x: lastX, y: lastY, price: lastPoint.price };
        }

        /**
         * Render extrema points on chart
         * @param {ExtremaPoint[]} extremaPoints - Extrema points to render
         */
        renderExtremaPoints(extremaPoints) {
            extremaPoints.forEach(point => {
                const pointX = this.x(new Date(point.timestamp));
                const pointY = this.y(point.price);
                const isTop = point.type === 'top';
                const color = isTop ? '#4caf50' : '#ff5252';

                // Background rectangle
                this.svg.append('rect')
                    .attr('class', 'extrema-label')
                    .attr('x', pointX - 30)
                    .attr('y', isTop ? pointY - 25 : pointY + 5)
                    .attr('width', 60)
                    .attr('height', 20)
                    .attr('rx', 3)
                    .attr('ry', 3)
                    .attr('fill', color)
                    .attr('opacity', 0.85);

                // Price text
                this.svg.append('text')
                    .attr('class', 'extrema-label')
                    .attr('x', pointX)
                    .attr('y', isTop ? pointY - 10 : pointY + 20)
                    .attr('text-anchor', 'middle')
                    .attr('fill', 'white')
                    .attr('font-size', '11px')
                    .attr('font-weight', 'bold')
                    .text(point.price.toLocaleString(undefined, {maximumFractionDigits: 0}));
            });
        }
    }

    // ===================================================
    // VIEW - Chart visualization
    // ===================================================
    /**
     * Main chart view
     */
    class ChartView {
        /**
         * Creates a chart view
         * @param {string} containerId - Chart container ID
         */
        constructor(containerId) {
            /** @type {HTMLElement} Main chart container */
            this.container = document.getElementById(containerId);

            /** @type {HTMLElement} Chart title element */
            this.chartTitle = document.getElementById('chart-title');

            /** @type {HTMLElement} Loading indicator */
            this.loadingEl = document.getElementById('loading');

            /** @type {HTMLElement} Current price label */
            this.currentPriceLabel = document.getElementById('current-price-label');

            // Chart configuration
            /** @type {{top: number, right: number, bottom: number, left: number}} */
            this.margin = { top: 20, right: 50, bottom: 50, left: 70 };

            /** @type {number} Chart width */
            this.width = 960 - this.margin.left - this.margin.right;

            /** @type {number} Chart height */
            this.height = 500 - this.margin.top - this.margin.bottom;

            // Initialize chart renderer
            this.renderer = new ChartRenderer(this.container, {
                width: this.width,
                height: this.height,
                margin: this.margin
            });

            // Get scales from renderer
            const scales = this.renderer.getScales();

            // Initialize UI components
            this.priceGuide = new PriceGuideComponent(this.container, scales);
            this.priceRange = new PriceRangeComponent(this.container, scales);
            this.controls = new ControlsComponent();

            // Store current data
            this.currentData = [];
        }

        /**
         * Set up event listeners
         * @param {object} callbacks - Callback functions for events
         */
        setupEventListeners(callbacks) {
            // Setup controls component listeners
            this.controls.setupEventListeners({
                onSymbolChange: callbacks.onSymbolChange,
                onIntervalChange: callbacks.onIntervalChange,
                onLimitChange: callbacks.onLimitChange,
                onThresholdChange: callbacks.onThresholdChange,
                onThresholdSet: callbacks.onThresholdSet,
                onRefresh: callbacks.onRefresh
            });

            // Mouse tracking for price guide
            this.container.addEventListener('mousemove', this.handleMouseMove.bind(this));
            this.container.addEventListener('mouseleave', () => this.priceGuide.hide());

            // Add drag selection handlers
            this.container.addEventListener('mousedown', this.handleMouseDown.bind(this));
            this.container.addEventListener('mousemove', this.handleDragMove.bind(this));
            this.container.addEventListener('mouseup', this.handleMouseUp.bind(this));

            // Add click handler to clear selection
            this.container.addEventListener('click', this.handleClick.bind(this));

            // Handle back/forward navigation
            window.addEventListener('popstate', () => {
                if (callbacks.onPopState) {
                    callbacks.onPopState();
                }
            });
        }

        /**
         * Handle mouse movement
         * @param {MouseEvent} event - Mouse event
         */
        handleMouseMove(event) {
            const chartRect = this.container.getBoundingClientRect();
            const relativeY = event.clientY - chartRect.top;

            if (this._isInChartArea(relativeY)) {
                this.priceGuide.update(relativeY, this.currentData);
            } else {
                this.priceGuide.hide();
            }

            // If we're dragging, don't interfere with the drag operation
            if (this.priceRange.isDraggingActive()) {
                event.preventDefault();
                event.stopPropagation();
            }
        }

        /**
         * Handle mouse down for drag selection
         * @param {MouseEvent} event - Mouse event
         */
        handleMouseDown(event) {
            const chartRect = this.container.getBoundingClientRect();
            const relativeY = event.clientY - chartRect.top;

            // Only start dragging if within chart area
            if (this._isInChartArea(relativeY)) {
                this.priceRange.startDrag(relativeY);
                this.priceGuide.hide();
            }
        }

        /**
         * Handle mouse move while dragging
         * @param {MouseEvent} event - Mouse event
         */
        handleDragMove(event) {
            if (!this.priceRange.isDraggingActive()) return;

            const chartRect = this.container.getBoundingClientRect();
            const relativeY = Math.max(
                this.margin.top,
                Math.min(event.clientY - chartRect.top, chartRect.height - this.margin.bottom)
            );

            this.priceRange.updateDrag(relativeY);
        }

        /**
         * Handle mouse up for drag selection
         * @param {MouseEvent} event - Mouse event
         */
        handleMouseUp(event) {
            this.priceRange.endDrag();
        }

        /**
         * Handle click to clear selection
         * @param {MouseEvent} event - Mouse event
         */
        handleClick(event) {
            // Clear the selection if not dragging
            if (!this.priceRange.isDraggingActive()) {
                this.priceRange.clear();
            }
        }

        /**
         * Check if position is in chart area
         * @param {number} y - Y coordinate
         * @returns {boolean} True if in chart area
         * @private
         */
        _isInChartArea(y) {
            const chartRect = this.container.getBoundingClientRect();
            return y >= this.margin.top && y <= (chartRect.height - this.margin.bottom);
        }

        /**
         * Update chart title based on parameters
         * @param {ChartParams} params - Chart parameters
         * @returns {string} Updated title
         */
        updateChartTitle(params) {
            const symbolDisplay = params.symbol.replace('USDT', '');
            const title = `${symbolDisplay} ${params.interval} Chart`;
            this.chartTitle.textContent = title;
            return title;
        }

        /**
         * Update UI controls based on parameters
         * @param {ChartParams} params - Chart parameters
         * @param {ThresholdRange} [thresholdRange] - Optional threshold range settings
         * @returns {Object} Current control values
         */
        updateControls(params, thresholdRange) {
            return this.controls.updateControls(params, thresholdRange);
        }

        /**
         * Show loading indicator
         * @param {string} [message] - Optional loading message
         */
        showLoading(message = 'Loading data...') {
            this.loadingEl.style.display = 'block';
            this.loadingEl.textContent = message;
        }

        /**
         * Hide loading indicator
         */
        hideLoading() {
            this.loadingEl.style.display = 'none';
        }

        /**
         * Show error message
         * @param {string} [message] - Error message
         */
        showError(message) {
            this.loadingEl.style.display = 'block';
            this.loadingEl.textContent = message || 'Error loading data. Please try again.';
        }

        /**
         * Render the chart with data
         * @param {PriceDataPoint[]} data - Price data points to render
         * @param {ExtremaPoint[]} [extremaPoints] - Optional extrema points to highlight
         * @returns {Object} Rendering results
         */
        renderChart(data, extremaPoints) {
            if (data.length === 0) return { success: false, reason: 'No data' };

            // Store current data for hover percentage calculations
            this.currentData = [...data];

            // Update scales
            const scaleInfo = this.renderer.updateScales(data);

            // Update axes
            this.renderer.updateAxes();

            // Update line and area paths
            this.renderer.updateChartLines(data);

            // Clear existing extrema labels
            this.renderer.clearLabels();

            // Draw current price indicator
            const lastPoint = data[data.length - 1];
            const currentPriceInfo = this.renderer.updateCurrentPriceIndicator(lastPoint);

            // Update price label
            this.currentPriceLabel.style.display = 'block';
            this.currentPriceLabel.textContent = ChartUtils.formatPrice(lastPoint.price);
            this.currentPriceLabel.style.top = `${currentPriceInfo.y + this.margin.top - 10}px`;

            // Add extrema points
            if (extremaPoints && extremaPoints.length > 0) {
                this.renderer.renderExtremaPoints(extremaPoints);
            }

            // Clear any existing price range selection
            this.priceRange.clear();

            return {
                success: true,
                dataPoints: data.length,
                extremaPoints: extremaPoints ? extremaPoints.length : 0,
                scaleInfo,
                currentPrice: lastPoint.price
            };
        }
    }

    // ===================================================
    // URL Parameter Handler
    // ===================================================
    /**
     * Handles URL parameter operations
     */
    class URLHandler {
        /**
         * Load parameters from URL
         * @param {ChartParams} defaults - Default parameters to use if not in URL
         * @returns {{params: ChartParams, thresholdRange: Partial<ThresholdRange>}} Parsed parameters and threshold range
         */
        static loadFromUrl(defaults) {
            const urlParams = new URLSearchParams(window.location.search);
            /** @type {ChartParams} */
            const params = { ...defaults };

            // Get parameters with validation
            if (urlParams.has('symbol')) {
                params.symbol = urlParams.get('symbol');
            }

            if (urlParams.has('interval')) {
                params.interval = urlParams.get('interval');
            }

            if (urlParams.has('limit')) {
                const parsedLimit = parseInt(urlParams.get('limit'), 10);
                if (!isNaN(parsedLimit) && parsedLimit > 0) {
                    params.limit = parsedLimit;
                }
            }

            if (urlParams.has('threshold')) {
                const parsedThreshold = parseFloat(urlParams.get('threshold'));
                if (!isNaN(parsedThreshold) && parsedThreshold >= 0) {
                    params.threshold = parsedThreshold;
                }
            }

            // Get threshold slider settings
            /** @type {Partial<ThresholdRange>} */
            const thresholdRange = {};

            if (urlParams.has('thresholdMin')) {
                const min = parseFloat(urlParams.get('thresholdMin'));
                if (!isNaN(min)) {
                    thresholdRange.min = min;
                }
            }

            if (urlParams.has('thresholdMax')) {
                const max = parseFloat(urlParams.get('thresholdMax'));
                if (!isNaN(max)) {
                    thresholdRange.max = max;
                }
            }

            if (urlParams.has('thresholdStep')) {
                const step = parseFloat(urlParams.get('thresholdStep'));
                if (!isNaN(step)) {
                    thresholdRange.step = step;
                }
            }

            return { params, thresholdRange };
        }

        /**
         * Update URL with current parameters without page reload
         * @param {ChartParams} params - Chart parameters to include in URL
         * @param {ThresholdRange} thresholdRange - Threshold range settings
         * @returns {string} New URL
         */
        static updateUrl(params, thresholdRange) {
            const urlParams = new URLSearchParams();

            // Add primary parameters
            urlParams.set('symbol', params.symbol);
            urlParams.set('interval', params.interval);
            urlParams.set('limit', params.limit.toString());
            urlParams.set('threshold', params.threshold.toString());

            // Add threshold slider settings if they differ from defaults
            if (thresholdRange.min !== 0) {
                urlParams.set('thresholdMin', thresholdRange.min.toString());
            }

            if (thresholdRange.max !== 1000) {
                urlParams.set('thresholdMax', thresholdRange.max.toString());
            }

            if (thresholdRange.step !== 1) {
                urlParams.set('thresholdStep', thresholdRange.step.toString());
            }

            // Update URL without reloading page
            const newUrl = `${window.location.pathname}?${urlParams.toString()}`;
            window.history.pushState({ path: newUrl }, '', newUrl);

            return newUrl;
        }
    }

    // ===================================================
    // Controller - App orchestration
    // ===================================================
    /**
     * Main controller for the chart application
     */
    class ChartController {
        /**
         * Creates a chart controller
         */
        constructor() {
            /** @type {ChartParams} Default settings */
            this.defaults = {
                symbol: 'BTCUSDT',
                interval: '1h',
                limit: 100,
                threshold: 0
            };

            /** @type {ChartModel} Data model */
            this.model = new ChartModel();

            /** @type {ChartView} UI view */
            this.view = new ChartView('chart-container');

            // Load initial state from URL
            this.loadFromUrl();

            // Setup event listeners
            this.setupEventListeners();

            // Initial chart render
            this.updateChart(true);
        }

        /**
         * Load settings from URL parameters
         * @returns {Object} Loaded parameters
         */
        loadFromUrl() {
            const { params, thresholdRange } = URLHandler.loadFromUrl(this.defaults);

            // Update model
            this.model.setParams(params);

            // Update threshold range if provided
            if (Object.keys(thresholdRange).length > 0) {
                this.model.updateThresholdRange(thresholdRange);
            }

            // Update view
            this.view.updateChartTitle(params);
            this.view.updateControls(params, this.model.getThresholdRange());

            return { params, thresholdRange };
        }

        /**
         * Set up event listeners
         */
        setupEventListeners() {
            this.view.setupEventListeners({
                onSymbolChange: this.handleSymbolChange.bind(this),
                onIntervalChange: this.handleIntervalChange.bind(this),
                onLimitChange: this.handleLimitChange.bind(this),
                onThresholdChange: this.handleThresholdChange.bind(this),
                onThresholdSet: this.handleThresholdSet.bind(this),
                onRefresh: this.handleRefresh.bind(this),
                onPopState: this.handlePopState.bind(this)
            });
        }

        /**
         * Handle symbol change
         * @param {string} symbol - New symbol value
         */
        handleSymbolChange(symbol) {
            const currentParams = this.model.getParams();
            if (currentParams.symbol === symbol) return;

            // Update model with new symbol and reset threshold
            const updatedParams = this.model.setParams({
                symbol,
                threshold: 0
            });

            // Update URL
            URLHandler.updateUrl(updatedParams, this.model.getThresholdRange());

            // Refresh chart
            this.updateChart(true);
        }

        /**
         * Handle interval change
         * @param {string} interval - New interval value
         */
        handleIntervalChange(interval) {
            const updatedParams = this.model.setParams({ interval });
            URLHandler.updateUrl(updatedParams, this.model.getThresholdRange());
            this.updateChart(true);
        }

        /**
         * Handle limit change
         * @param {number} limit - New limit value
         */
        handleLimitChange(limit) {
            const updatedParams = this.model.setParams({ limit });
            URLHandler.updateUrl(updatedParams, this.model.getThresholdRange());
            this.updateChart(true);
        }

        /**
         * Handle threshold slider change (live update)
         * @param {number} threshold - New threshold value
         */
        handleThresholdChange(threshold) {
            this.model.setParams({ threshold });

            // Only update chart, don't update URL yet (wait for mouse release)
            if (this.model.rawData.length > 0) {
                const { filteredData, extremaPoints } = this.model.processData();
                this.view.renderChart(filteredData, extremaPoints);
            }
        }

        /**
         * Handle threshold slider set (after mouse release)
         * @param {number} threshold - Final threshold value
         */
        handleThresholdSet(threshold) {
            const updatedParams = this.model.setParams({ threshold });
            URLHandler.updateUrl(updatedParams, this.model.getThresholdRange());
        }

        /**
         * Handle refresh button click
         */
        handleRefresh() {
            this.updateChart(true);
        }

        /**
         * Handle browser back/forward navigation
         */
        handlePopState() {
            this.loadFromUrl();
            this.updateChart(true);
        }

        /**
         * Calculate and update threshold slider based on price data
         * @param {PriceDataPoint[]} data - Price data points
         * @returns {ThresholdRange|null} New threshold range or null if data is empty
         */
        calculateThresholdRange(data) {
            if (data.length === 0) return null;

            const lastPrice = data[data.length - 1].price;
            const range = ChartUtils.calculateThresholdRange(lastPrice);

            return range;
        }

        /**
         * Fetch data and update chart
         * @param {boolean} [forceRefresh=false] - Force data refresh from API
         * @returns {Promise<Object>} Update results
         */
        async updateChart(forceRefresh = false) {
            // Update chart title
            const params = this.model.getParams();
            this.view.updateChartTitle(params);

            try {
                let chartData;

                // Show loading indicator for new data
                if (this.model.rawData.length === 0 || forceRefresh) {
                    this.view.showLoading();
                    chartData = await this.model.fetchData();
                } else {
                    // Use existing data
                    chartData = this.model.processData();
                }

                const { filteredData, extremaPoints } = chartData;

                // Update threshold slider based on data for new data
                if (forceRefresh && filteredData.length > 0) {
                    const newRange = this.calculateThresholdRange(filteredData);
                    if (newRange) {
                        this.model.updateThresholdRange(newRange);
                        this.view.updateControls(params, newRange);
                    }
                }

                // Hide loading and render chart
                this.view.hideLoading();
                const renderResult = this.view.renderChart(filteredData, extremaPoints);

                return {
                    success: true,
                    renderResult,
                    dataPoints: filteredData.length
                };
            } catch (error) {
                console.error('Error updating chart:', error);

                // Provide specific error messages based on error type
                let errorMessage = 'Error loading data. Please try again.';
                if (error.message.includes('API error')) {
                    errorMessage = 'Server error. Please try again later.';
                } else if (error.message.includes('network')) {
                    errorMessage = 'Network error. Please check your connection.';
                }

                this.view.showError(errorMessage);

                return {
                    success: false,
                    error: errorMessage,
                    originalError: error.message
                };
            }
        }
    }

    // Initialize the chart application
    document.addEventListener('DOMContentLoaded', () => {
        window.cryptoChart = new ChartController();
    });
</script>
</body>
</html>